<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Sway Programming Language</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">The Sway Programming Language</a></li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="introduction/sway_quickstart.html"><strong aria-hidden="true">1.2.</strong> Sway Quickstart</a></li><li class="chapter-item expanded "><a href="introduction/fuel_toolchain.html"><strong aria-hidden="true">1.3.</strong> The Fuel Toolchain</a></li><li class="chapter-item expanded "><a href="introduction/forc_project.html"><strong aria-hidden="true">1.4.</strong> A Forc Project</a></li><li class="chapter-item expanded "><a href="introduction/standard_library.html"><strong aria-hidden="true">1.5.</strong> Standard Library</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/counter.html"><strong aria-hidden="true">2.1.</strong> Counter</a></li><li class="chapter-item expanded "><a href="examples/subcurrency.html"><strong aria-hidden="true">2.2.</strong> Subcurrency</a></li><li class="chapter-item expanded "><a href="examples/fizzbuzz.html"><strong aria-hidden="true">2.3.</strong> FizzBuzz</a></li><li class="chapter-item expanded "><a href="examples/wallet_smart_contract.html"><strong aria-hidden="true">2.4.</strong> Wallet Smart Contract</a></li></ol></li><li class="chapter-item expanded "><a href="sway-program-types/index.html"><strong aria-hidden="true">3.</strong> Program Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sway-program-types/smart_contracts.html"><strong aria-hidden="true">3.1.</strong> Contracts</a></li><li class="chapter-item expanded "><a href="sway-program-types/libraries.html"><strong aria-hidden="true">3.2.</strong> Libraries</a></li><li class="chapter-item expanded "><a href="sway-program-types/scripts.html"><strong aria-hidden="true">3.3.</strong> Scripts</a></li><li class="chapter-item expanded "><a href="sway-program-types/predicates.html"><strong aria-hidden="true">3.4.</strong> Predicates</a></li></ol></li><li class="chapter-item expanded "><a href="basics/index.html"><strong aria-hidden="true">4.</strong> Sway Language Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/variables.html"><strong aria-hidden="true">4.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="basics/built_in_types.html"><strong aria-hidden="true">4.2.</strong> Built-in Types</a></li><li class="chapter-item expanded "><a href="basics/commonly_used_library_types.html"><strong aria-hidden="true">4.3.</strong> Commonly Used Library Types</a></li><li class="chapter-item expanded "><a href="basics/blockchain_types.html"><strong aria-hidden="true">4.4.</strong> Blockchain Types</a></li><li class="chapter-item expanded "><a href="basics/functions.html"><strong aria-hidden="true">4.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="basics/structs_tuples_and_enums.html"><strong aria-hidden="true">4.6.</strong> Structs, Tuples, and Enums</a></li><li class="chapter-item expanded "><a href="basics/methods_and_associated_functions.html"><strong aria-hidden="true">4.7.</strong> Methods and Associated Functions</a></li><li class="chapter-item expanded "><a href="basics/constants.html"><strong aria-hidden="true">4.8.</strong> Constants</a></li><li class="chapter-item expanded "><a href="basics/comments_and_logging.html"><strong aria-hidden="true">4.9.</strong> Comments and Logging</a></li><li class="chapter-item expanded "><a href="basics/control_flow.html"><strong aria-hidden="true">4.10.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="blockchain-development/index.html"><strong aria-hidden="true">5.</strong> Blockchain Development with Sway</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blockchain-development/hashing_and_cryptography.html"><strong aria-hidden="true">5.1.</strong> Hashing and Cryptography</a></li><li class="chapter-item expanded "><a href="blockchain-development/storage.html"><strong aria-hidden="true">5.2.</strong> Contract Storage</a></li><li class="chapter-item expanded "><a href="blockchain-development/purity.html"><strong aria-hidden="true">5.3.</strong> Function Purity</a></li><li class="chapter-item expanded "><a href="blockchain-development/identifiers.html"><strong aria-hidden="true">5.4.</strong> Identifiers</a></li><li class="chapter-item expanded "><a href="blockchain-development/native_assets.html"><strong aria-hidden="true">5.5.</strong> Native Assets</a></li><li class="chapter-item expanded "><a href="blockchain-development/access_control.html"><strong aria-hidden="true">5.6.</strong> Access Control</a></li><li class="chapter-item expanded "><a href="blockchain-development/calling_contracts.html"><strong aria-hidden="true">5.7.</strong> Calling Contracts</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/index.html"><strong aria-hidden="true">6.</strong> Advanced Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/advanced_types.html"><strong aria-hidden="true">6.1.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="advanced/generic_types.html"><strong aria-hidden="true">6.2.</strong> Generic Types</a></li><li class="chapter-item expanded "><a href="advanced/traits.html"><strong aria-hidden="true">6.3.</strong> Traits</a></li><li class="chapter-item expanded "><a href="advanced/generics_and_trait_constraints.html"><strong aria-hidden="true">6.4.</strong> Generics and Trait Constraints</a></li><li class="chapter-item expanded "><a href="advanced/assembly.html"><strong aria-hidden="true">6.5.</strong> Assembly</a></li></ol></li><li class="chapter-item expanded "><a href="common-collections/index.html"><strong aria-hidden="true">7.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="common-collections/vec.html"><strong aria-hidden="true">7.1.</strong> Vectors on the Heap</a></li><li class="chapter-item expanded "><a href="common-collections/storage_vec.html"><strong aria-hidden="true">7.2.</strong> Storage Vectors</a></li><li class="chapter-item expanded "><a href="common-collections/storage_map.html"><strong aria-hidden="true">7.3.</strong> Storage Maps</a></li></ol></li><li class="chapter-item expanded "><a href="testing/index.html"><strong aria-hidden="true">8.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/unit-testing.html"><strong aria-hidden="true">8.1.</strong> Unit Testing</a></li><li class="chapter-item expanded "><a href="testing/testing-with-rust.html"><strong aria-hidden="true">8.2.</strong> Testing with Rust</a></li></ol></li><li class="chapter-item expanded "><a href="frontend/index.html"><strong aria-hidden="true">9.</strong> Application Frontend</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="frontend/typescript_sdk.html"><strong aria-hidden="true">9.1.</strong> TypeScript SDK</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">10.</strong> Sway Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/compiler_intrinsics.html"><strong aria-hidden="true">10.1.</strong> Compiler Intrinsics</a></li><li class="chapter-item expanded "><a href="reference/attributes.html"><strong aria-hidden="true">10.2.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="reference/style_guide.html"><strong aria-hidden="true">10.3.</strong> Style Guide</a></li><li class="chapter-item expanded "><a href="reference/known_issues_and_workarounds.html"><strong aria-hidden="true">10.4.</strong> Known Issues and Workarounds</a></li><li class="chapter-item expanded "><a href="reference/solidity_differences.html"><strong aria-hidden="true">10.5.</strong> Differences From Solidity</a></li><li class="chapter-item expanded "><a href="reference/rust_differences.html"><strong aria-hidden="true">10.6.</strong> Differences From Rust</a></li><li class="chapter-item expanded "><a href="reference/contributing_to_sway.html"><strong aria-hidden="true">10.7.</strong> Contributing To Sway</a></li></ol></li><li class="chapter-item expanded "><a href="forc/index.html"><strong aria-hidden="true">11.</strong> Forc Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc/manifest_reference.html"><strong aria-hidden="true">11.1.</strong> Manifest Reference</a></li><li class="chapter-item expanded "><a href="forc/workspaces.html"><strong aria-hidden="true">11.2.</strong> Workspaces</a></li><li class="chapter-item expanded "><a href="forc/dependencies.html"><strong aria-hidden="true">11.3.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="forc/commands/index.html"><strong aria-hidden="true">11.4.</strong> Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc/commands/forc_addr2line.html"><strong aria-hidden="true">11.4.1.</strong> forc addr2line</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_build.html"><strong aria-hidden="true">11.4.2.</strong> forc build</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_check.html"><strong aria-hidden="true">11.4.3.</strong> forc check</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_clean.html"><strong aria-hidden="true">11.4.4.</strong> forc clean</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_completions.html"><strong aria-hidden="true">11.4.5.</strong> forc completions</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_contract-id.html"><strong aria-hidden="true">11.4.6.</strong> forc contract-id</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_init.html"><strong aria-hidden="true">11.4.7.</strong> forc init</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_new.html"><strong aria-hidden="true">11.4.8.</strong> forc new</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_parse-bytecode.html"><strong aria-hidden="true">11.4.9.</strong> forc parse-bytecode</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_plugins.html"><strong aria-hidden="true">11.4.10.</strong> forc plugins</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_predicate-root.html"><strong aria-hidden="true">11.4.11.</strong> forc predicate-root</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_test.html"><strong aria-hidden="true">11.4.12.</strong> forc test</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_update.html"><strong aria-hidden="true">11.4.13.</strong> forc update</a></li><li class="chapter-item expanded "><a href="forc/commands/forc_template.html"><strong aria-hidden="true">11.4.14.</strong> forc template</a></li></ol></li><li class="chapter-item expanded "><a href="forc/plugins/index.html"><strong aria-hidden="true">11.5.</strong> Plugins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc/plugins/forc_client/index.html"><strong aria-hidden="true">11.5.1.</strong> forc client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc/plugins/forc_client/forc_deploy.html"><strong aria-hidden="true">11.5.1.1.</strong> forc deploy</a></li><li class="chapter-item expanded "><a href="forc/plugins/forc_client/forc_run.html"><strong aria-hidden="true">11.5.1.2.</strong> forc run</a></li><li class="chapter-item expanded "><a href="forc/plugins/forc_client/forc_submit.html"><strong aria-hidden="true">11.5.1.3.</strong> forc submit</a></li></ol></li><li class="chapter-item expanded "><a href="forc/plugins/forc_doc.html"><strong aria-hidden="true">11.5.2.</strong> forc doc</a></li><li class="chapter-item expanded "><a href="forc/plugins/forc_explore.html"><strong aria-hidden="true">11.5.3.</strong> forc explore</a></li><li class="chapter-item expanded "><a href="forc/plugins/forc_fmt.html"><strong aria-hidden="true">11.5.4.</strong> forc fmt</a></li><li class="chapter-item expanded "><a href="forc/plugins/forc_lsp.html"><strong aria-hidden="true">11.5.5.</strong> forc lsp</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Sway Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/FuelLabs/sway" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-sway-programming-language"><a class="header" href="#the-sway-programming-language">The Sway Programming Language</a></h1>
<p>Sway is a domain-specific language (DSL) for the <a href="https://fuellabs.github.io/fuel-specs/master/vm/index.html">Fuel Virtual Machine (FuelVM)</a>, a blockchain-optimized VM designed for the Fuel blockchain. Sway is based on <a href="https://doc.rust-lang.org/book/">Rust</a>, and includes syntax to leverage a blockchain VM without needlessly verbose boilerplate.</p>
<p>This book documents how to write smart contracts in Sway, along with how to install and use the Sway toolchain.</p>
<p>Before starting developing smart contracts in Sway, please keep in mind the <a href="./reference/known_issues_and_workarounds.html">known issues and workarounds</a> of the language and toolchain.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>To get started with Forc and Sway smart contract development, install the Fuel toolchain and Fuel full node and set up your first project.</p>
<ul>
<li><a href="introduction/./installation.html">Installation</a></li>
<li><a href="introduction/./sway_quickstart.html">Sway Quickstart</a></li>
<li><a href="introduction/./fuel_toolchain.html">The Fuel Toolchain</a></li>
<li><a href="introduction/./forc_project.html">A Forc Project</a></li>
<li><a href="introduction/./standard_library.html">Standard Library</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>The <em>Sway toolchain</em> is sufficient to compile Sway smart contracts. Otherwise, note that if you want to run Sway smart contracts (e.g. for testing), a Fuel Core full node is required, which is packaged together with the <em>Sway toolchain</em> together as the <em>Fuel toolchain</em>.</p>
<h2 id="install-via-pre-compiled-binaries-recommended"><a class="header" href="#install-via-pre-compiled-binaries-recommended">Install via Pre-compiled Binaries (Recommended)</a></h2>
<p>Installing via pre-compiled release binaries is the recommended way to get up and running with the Sway toolchain. Pre-compiled binaries for Linux and macOS are available. Native Windows is currently unsupported (<a href="https://github.com/FuelLabs/sway/issues/1526">tracking issue for Windows support</a>). Windows Subsystem for Linux should work but is not officially supported.</p>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>A prerequisite for installing and using Sway is the Rust toolchain. Platform-specific instructions for installing <code>rustup</code> can be found <a href="https://www.rust-lang.org/tools/install">here</a>. Then, install the Rust toolchain with:</p>
<pre><code class="language-sh"># Install the latest stable Rust toolchain.
rustup install stable
</code></pre>
<p>The Sway toolchain is built and tested against the <code>stable</code> Rust toolchain version (<a href="https://github.com/rust-lang/rust/releases/latest">https://github.com/rust-lang/rust/releases/latest</a>). There is no guarantee it will work with the <code>nightly</code> Rust toolchain, or with earlier <code>stable</code> versions, so ensure you are using <code>stable</code> with:</p>
<pre><code class="language-sh"># Update installed Rust toolchain; can be used independently.
rustup update
# Set the stable Rust toolchain as default; can be used independently.
rustup default stable
</code></pre>
<p>Now you're ready to install <a href="https://github.com/FuelLabs/fuelup"><code>fuelup</code></a>, the equivalent of Rust's <code>rustup</code> for the Fuel toolchain. It enables easily downloading binary releases of the Fuel toolchain.</p>
<ol>
<li>
<p>Start by installing <code>fuelup</code> with the following command:</p>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -sSf \
https://install.fuel.network/fuelup-init.sh | sh
</code></pre>
<p>This downloads the <code>fuelup-init</code> script to a temp directory on your machine, which installs <code>fuelup</code>. <code>fuelup-init</code> will ask for permission to add <code>~/.fuelup/bin</code> to your PATH. Otherwise, you can also pass <code>--no-modify-path</code> so that <code>fuelup-init</code> does not modify your PATH:</p>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -sSf \
https://install.fuel.network/fuelup-init.sh | sh -s -- --no-modify-path
</code></pre>
</li>
<li>
<p>Once fuelup is installed, fuelup-init automatically runs <code>fuelup toolchain install latest</code> to install the latest toolchain</p>
<p>You can run <code>fuelup update</code> at anytime to get the most up-to-date toolchain.</p>
</li>
<li>
<p>(Optional) You can optionally install distributed toolchains optimized for different networks.</p>
<p>To configure the optimal toolchain for beta-3, run the following commands:</p>
<pre><code class="language-sh">$ fuelup self update
Fetching binary from https://github.com/FuelLabs/fuelup/releases/download/v0.18.0/fuelup-0.18.0-aarch64-apple-darwin.tar.gz
 Downloading component fuelup without verifying checksum
 Unpacking and moving fuelup to /var/folders/tp/0l8zdx9j4s9_n609ykwxl0qw0000gn/T/.tmpP3HfvR
 Moving /var/folders/tp/0l8zdx9j4s9_n609ykwxl0qw0000gn/T/.tmpP3HfvR/fuelup to /Users/user/.fuelup/bin/fuelup


$ fuelup toolchain install beta-3
Downloading: forc forc-explore forc-wallet fuel-core fuel-indexer

Adding component forc v0.35.0 to 'beta-3-aarch64-apple-darwin'
Fetching binary from https://github.com/FuelLabs/sway/releases/download/v0.35.0/forc-binaries-darwin_arm64.tar.gz
npacking and moving forc-doc to /Users/user/.fuelup/toolchains/beta-3-aarch64-apple-darwin/bin
Unpacking and moving forc to /Users/user/.fuelup/toolchains/beta-3-aarch64-apple-darwin/bin
Unpacking and moving forc-deploy to /Users/user/.fuelup/toolchains/beta-3-aarch64-apple-darwin/bin
Unpacking and moving forc-run to /Users/user/.fuelup/toolchains/beta-3-aarch64-apple-darwin/bin
Unpacking and moving forc-lsp to /Users/user/.fuelup/toolchains/beta-3-aarch64-apple-darwin/bin
Unpacking and moving forc-fmt to /Users/user/.fuelup/toolchains/beta-3-aarch64-apple-darwin/bin
Fetching core forc dependencies
Installed forc v0.35.0 for toolchain 'beta-3-aarch64-apple-darwin'

Adding component forc-explore v0.28.1 to 'beta-3-aarch64-apple-darwin'
Fetching binary from https://github.com/FuelLabs/forc-explorer/releases/download/v0.28.1/forc-explore-0.28.1-aarch64-apple-darwin.tar.gz
Unpacking and moving forc-explore to /Users/user/.fuelup/toolchains/beta-3-aarch64-apple-darwin/bin
Installed forc-explore v0.28.1 for toolchain 'beta-3-aarch64-apple-darwin'

Adding component forc-wallet v0.1.3 to 'beta-3-aarch64-apple-darwin'
Fetching binary from https://github.com/FuelLabs/forc-wallet/releases/download/v0.1.3/forc-wallet-0.1.3-aarch64-apple-darwin.tar.gz
Unpacking and moving forc-wallet to /Users/user/.fuelup/toolchains/beta-3-aarch64-apple-darwin/bin
Installed forc-wallet v0.1.3 for toolchain 'beta-3-aarch64-apple-darwin'

Adding component fuel-core v0.17.1 to 'beta-3-aarch64-apple-darwin'
Fetching binary from https://github.com/FuelLabs/fuel-core/releases/download/v0.17.1/fuel-core-0.17.1-aarch64-apple-darwin.tar.gz
Unpacking and moving fuel-core to /Users/user/.fuelup/toolchains/    beta-3-aarch64-apple-darwin/bin
Installed fuel-core v0.17.1 for toolchain 'beta-3-aarch64-apple-darwin'

Adding component fuel-indexer v0.2.3 to 'beta-3-aarch64-apple-darwin'
Fetching binary from https://github.com/FuelLabs/fuel-indexer/releases/download/v0.2.3/fuel-indexer-0.2.3-aarch64-apple-darwin.tar.gz
Unpacking and moving fuel-indexer to /Users/user/.fuelup/toolchains/beta-3-aarch64-apple-darwin/bin
Installed fuel-indexer v0.2.3 for toolchain 'beta-3-aarch64-apple-darwin'

Installed:
- forc 0.35.0
- forc-explore 0.28.1
- forc-wallet 0.1.3
- fuel-core 0.17.1
- fuel-indexer 0.2.3

The Fuel toolchain is installed and up to date
</code></pre>
</li>
</ol>
<p>You're all set to start building!</p>
<h3 id="need-help"><a class="header" href="#need-help">Need Help?</a></h3>
<p>You may refer to <a href="https://fuellabs.github.io/fuelup/latest/">The Fuelup Book</a> for an in-depth look into fuelup, or check out the tooling section in the <a href="https://forum.fuel.network/">Fuel forum</a> if you're running into problems through the installation process. If you don't see your question, post the issue you're running into with as many details as possible and the team will get back to you asap!</p>
<h3 id="installing-from-cargo"><a class="header" href="#installing-from-cargo">Installing from Cargo</a></h3>
<p>The Sway toolchain and Fuel Core full node can be installed from source with Cargo with:</p>
<pre><code class="language-sh">cargo install forc fuel-core
</code></pre>
<h4 id="updating-forc-from-cargo"><a class="header" href="#updating-forc-from-cargo">Updating <code>forc</code> from Cargo</a></h4>
<p>You can update the toolchain from source with Cargo with:</p>
<pre><code class="language-sh">cargo update forc fuel-core
</code></pre>
<h4 id="installing-forc-plugins-from-cargo"><a class="header" href="#installing-forc-plugins-from-cargo">Installing <code>forc</code> Plugins from Cargo</a></h4>
<p>The Fuel ecosystem has a few plugins which can be easily installed via Cargo.</p>
<blockquote>
<p><strong>Note</strong>: <code>forc</code> detects anything in your <code>$PATH</code> prefixed with <code>forc-</code> as a plugin. Use <code>forc plugins</code> to see what you currently have installed.</p>
</blockquote>
<pre><code class="language-sh"># Sway Formatter
cargo install forc-fmt

# Block Explorer
cargo install forc-explore

# Sway Language Server
cargo install forc-lsp
</code></pre>
<h2 id="installing-from-source"><a class="header" href="#installing-from-source">Installing from Source</a></h2>
<p>Rather than installing from <code>cargo</code>, the Sway toolchain can be built from a local source checkout by following instructions at <a href="https://github.com/FuelLabs/sway">https://github.com/FuelLabs/sway</a>. The Fuel Core full node implementation can be built from source by following instructions at <a href="https://github.com/FuelLabs/fuel-core">https://github.com/FuelLabs/fuel-core</a>.</p>
<h2 id="enable-tab-completion-for-bash-fish-zsh-or-powershell"><a class="header" href="#enable-tab-completion-for-bash-fish-zsh-or-powershell">Enable tab completion for Bash, Fish, Zsh, or PowerShell</a></h2>
<p><code>forc</code> supports generating completion scripts for Bash, Fish, Zsh, and PowerShell. See <code>forc completions --help</code> for full details, but the gist is as simple as using one of the following:</p>
<pre><code class="language-sh"># Bash
forc completions --shell=bash &gt; ~/.local/share/bash-completion/completions/forc

# Bash (macOS/Homebrew)
forc completions --shell=bash &gt; $(brew --prefix)/etc/bash_completion.d/forc.bash-completion

# Fish
mkdir -p ~/.config/fish/completions
forc completions --shell=fish &gt; ~/.config/fish/completions/forc.fish

# Zsh
forc completions --shell=zsh &gt; ~/.zfunc/_forc

# PowerShell v5.0+
forc completions --shell=powershell &gt;&gt; $PROFILE.CurrentUserCurrentHost
# or
forc completions --shell=powershell | Out-String | Invoke-Expression
</code></pre>
<p>Once the completions have been generated and properly installed, close and reopen your terminal for the new completions to take effect.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-quickstart"><a class="header" href="#sway-quickstart">Sway Quickstart</a></h1>
<p>Check out the <a target="_blank" rel="noopener noreferrer" href="https://fuelbook.fuel.network/master/quickstart/developer-quickstart.html">Developer Quickstart Guide</a> for a step-by-step guide on building a fullstack dapp on Fuel. The guide will walk you through writing a smart contract, setting up a wallet, and building a frontend to interact with your contract.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-fuel-toolchain"><a class="header" href="#the-fuel-toolchain">The Fuel Toolchain</a></h1>
<p>The Fuel toolchain consists of several components.</p>
<h2 id="forc-forc"><a class="header" href="#forc-forc">Forc (<code>forc</code>)</a></h2>
<p>The &quot;Fuel Orchestrator&quot; <a href="https://github.com/FuelLabs/sway/tree/master/forc">Forc</a> is our equivalent of Rust's <a href="https://doc.rust-lang.org/cargo/">Cargo</a>. It is the primary entry point for creating, building, testing, and deploying Sway projects.</p>
<h2 id="sway-language-server-forc-lsp"><a class="header" href="#sway-language-server-forc-lsp">Sway Language Server (<code>forc-lsp</code>)</a></h2>
<p>The Sway Language Server <code>forc-lsp</code> is provided to expose features to IDEs. <a href="introduction/./installation.html">Installation instructions</a>.</p>
<p>Currently, only <a href="https://marketplace.visualstudio.com/items?itemName=FuelLabs.sway-vscode-plugin">Visual Studio Code is supported through a plugin</a>. Vim support is forthcoming, though <a href="https://github.com/FuelLabs/sway.vim">syntax highlighting is provided</a>.</p>
<blockquote>
<p><strong>Note</strong>: There is no need to manually run <code>forc-lsp</code> (the plugin will automatically start it), however both <code>forc</code> and <code>forc-lsp</code> must be in your <code>$PATH</code>. To check if <code>forc</code> is in your <code>$PATH</code>, type <code>forc --help</code> in your terminal.</p>
</blockquote>
<h2 id="sway-formatter-forc-fmt"><a class="header" href="#sway-formatter-forc-fmt">Sway Formatter (<code>forc-fmt</code>)</a></h2>
<p>A canonical formatter is provided with <code>forc-fmt</code>. <a href="introduction/./installation.html">Installation instructions</a>. It can be run manually with</p>
<pre><code class="language-sh">forc fmt
</code></pre>
<p>The <a href="https://marketplace.visualstudio.com/items?itemName=FuelLabs.sway-vscode-plugin">Visual Studio Code plugin</a> will
automatically format Sway files with <code>forc-fmt</code> on save, though you might have to explicitly set the Sway plugin as the
default formatter, like this:</p>
<pre><code class="language-json">&quot;[sway]&quot;: {
  &quot;editor.defaultFormatter&quot;: &quot;FuelLabs.sway-vscode-plugin&quot;
}
</code></pre>
<h2 id="fuel-core-fuel-core"><a class="header" href="#fuel-core-fuel-core">Fuel Core (<code>fuel-core</code>)</a></h2>
<p>An implementation of the Fuel protocol, <a href="https://github.com/FuelLabs/fuel-core">Fuel Core</a>, is provided together with the <em>Sway toolchain</em> to form the <em>Fuel toolchain</em>. <a href="https://github.com/FuelLabs/fuels-rs">The Rust SDK</a> will automatically start and stop an instance of the node during tests, so there is no need to manually run a node unless using Forc directly without the SDK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-forc-project"><a class="header" href="#a-forc-project">A Forc Project</a></h1>
<p>To initialize a new project with Forc, use <code>forc new</code>:</p>
<pre><code class="language-sh">forc new my-fuel-project
</code></pre>
<p>Here is the project that Forc has initialized:</p>
<!-- This section should show the tree for a new forc project -->
<!-- tree:example:start -->
<pre><code class="language-console">$ cd my-fuel-project
$ tree .
├── Forc.toml
└── src
    └── main.sw
</code></pre>
<!-- tree:example:end -->
<!-- This section should explain the `Forc.toml` file -->
<!-- forc_toml:example:start -->
<p><code>Forc.toml</code> is the <em>manifest file</em> (similar to <code>Cargo.toml</code> for Cargo or <code>package.json</code> for Node), and defines project metadata such as the project name and dependencies.</p>
<!-- forc_toml:example:end -->
<p>For additional information on dependency management, see: <a href="introduction/../forc/dependencies.html">here</a>.</p>
<pre><code class="language-toml">[project]
authors = [&quot;User&quot;]
entry = &quot;main.sw&quot;
license = &quot;Apache-2.0&quot;
name = &quot;my-fuel-project&quot;

[dependencies]
</code></pre>
<p>Here are the contents of the only Sway file in the project, and the main entry point, <code>src/main.sw</code>:</p>
<pre><code class="language-sway">contract;

abi MyContract {
    fn test_function() -&gt; bool;
}

impl MyContract for Contract {
    fn test_function() -&gt; bool {
        true
    }
}
</code></pre>
<p>The project is a <em>contract</em>, one of four different project types. For additional information on different project types, see <a href="introduction/../sway-program-types/index.html">here</a>.</p>
<p>We now compile our project with <code>forc build</code>, passing the flag <code>--finalized-asm</code> to view the generated assembly:</p>
<pre><code class="language-console">$ forc build --finalized-asm
...
.program:
ji   i4
noop
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
lw   $ds $is 1
add  $$ds $$ds $is
lw   $r0 $fp i73              ; load input function selector
lw   $r1 data_0               ; load fn selector for comparison
eq   $r2 $r0 $r1              ; function selector comparison
jnzi $r2 i12                  ; jump to selected function
movi $$tmp i123               ; special code for mismatched selector
rvrt $$tmp                    ; revert if no selectors matched
ret  $one
.data:
data_0 .word 559005003

  Compiled contract &quot;my-fuel-project&quot;.
  Bytecode size is 60 bytes.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<!-- This section should explain what the std-lib is -->
<!-- std_lib:example:start -->
<p>Similar to Rust, Sway comes with its own standard library.</p>
<p>The Sway Standard Library is the foundation of portable Sway software, a set of minimal shared abstractions for the broader Sway ecosystem. It offers core types, like <code>Result&lt;T, E&gt;</code> and <code>Option&lt;T&gt;</code>, library-defined operations on language primitives, native asset management, blockchain contextual operations, access control, storage management, and support for types from other VMs, among many other things.</p>
<!-- std_lib:example:end -->
<p>The entire Sway standard library is a Forc project called <code>std</code>, and is available directly here: <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">https://github.com/FuelLabs/sway/tree/master/sway-lib-std</a> (navigate to the appropriate tagged release if the latest <code>master</code> is not compatible). For the latest <code>std</code> documentation see: <a href="https://fuellabs.github.io/sway/master/std/">https://fuellabs.github.io/sway/master/std/</a>.</p>
<h2 id="using-the-standard-library"><a class="header" href="#using-the-standard-library">Using the Standard Library</a></h2>
<p>The standard library is made implicitly available to all Forc projects created using <a href="introduction/../forc/commands/forc_new.html"><code>forc new</code></a>. In other words, it is not required to manually specify <code>std</code> as an explicit dependency. Forc will automatically use the version of <code>std</code> that matches its version.</p>
<p>Importing items from the standard library can be done using the <code>use</code> keyword, just as importing items from any Sway project. For example:</p>
<pre><code class="language-sway">use std::storage::storage_vec::*;
</code></pre>
<p>This imports the <code>StorageVec</code> type into the current namespace.</p>
<h2 id="standard-library-prelude"><a class="header" href="#standard-library-prelude">Standard Library Prelude</a></h2>
<!-- This section should explain what the std-lib prelude is -->
<!-- prelude:example:start -->
<p>Sway comes with a variety of things in its standard library. However, if you had to manually import every single thing that you used, it would be very verbose. But importing a lot of things that a program never uses isn't good either. A balance needs to be struck.</p>
<p>The prelude is the list of things that Sway automatically imports into every Sway program. It's kept as small as possible, and is focused on things which are used in almost every single Sway program.</p>
<p>The current version of the prelude lives in <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/prelude.sw"><code>std::prelude</code></a>, and re-exports the following:</p>
<ul>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/address.sw"><code>std::address::Address</code></a>, a wrapper around the <code>b256</code> type representing a wallet address.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/contract_id.sw"><code>std::contract_id::ContractId</code></a>, a wrapper around the <code>b256</code> type representing the ID of a contract.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/identity.sw"><code>std::identity::Identity</code></a>, an enum with two possible variants: <code>Address: Address</code> and <code>ContractId: ContractId</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/vec.sw"><code>std::vec::Vec</code></a>, a growable, heap-allocated vector.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage/storage_key.sw"><code>std::storage::storage_key::*</code></a>, contains the API for accessing a <code>core::storage::StorageKey</code> which describes a location in storage.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage/storage_map.sw"><code>std::storage::storage_map::*</code></a>, a key-value mapping in contract storage.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/option.sw"><code>std::option::Option</code></a>, an enum which expresses the presence or absence of a value.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/result.sw"><code>std::result::Result</code></a>, an enum for functions that may succeed or fail.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/assert.sw"><code>std::assert::assert</code></a>, a function that reverts the VM if the condition provided to it is <code>false</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/assert.sw"><code>std::assert::assert_eq</code></a>, a function that reverts the VM and logs its two inputs <code>v1</code> and <code>v2</code> if the condition <code>v1</code> == <code>v2</code> is <code>false</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/revert.sw"><code>std::revert::require</code></a>, a function that reverts the VM and logs a given value if the condition provided to it is <code>false</code>.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/revert.sw"><code>std::revert::revert</code></a>, a function that reverts the VM.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/logging.sw"><code>std::logging::log</code></a>, a function that logs arbitrary stack types.</li>
<li><a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/auth.sw"><code>std::auth::msg_sender</code></a>, a function that gets the <code>Identity</code> from which a call was made.</li>
</ul>
<!-- prelude:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">Example</a></h1>
<p>Some basic example contracts to see how Sway and Forc work.</p>
<ul>
<li><a href="examples/./counter.html">Counter</a></li>
<li><a href="examples/./subcurrency.html">Subcurrency</a></li>
<li><a href="examples/./fizzbuzz.html">FizzBuzz</a></li>
<li><a href="examples/./wallet_smart_contract.html">Wallet Smart Contract</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="counter"><a class="header" href="#counter">Counter</a></h1>
<p>The following is a simple example of a contract which implements a counter. Both the <code>initialize_counter()</code> and <code>increment_counter()</code> ABI methods return the currently set value.</p>
<pre><code class="language-bash">forc template --template-name counter my_counter_project
</code></pre>
<pre><code class="language-sway">contract;

abi TestContract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64;

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64;
}

storage {
    counter: u64 = 0,
}

impl TestContract for Contract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64 {
        storage.counter.write(value);
        value
    }

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64 {
        let incremented = storage.counter.read() + amount;
        storage.counter.write(incremented);
        incremented
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subcurrency"><a class="header" href="#subcurrency">Subcurrency</a></h1>
<p>The following is a simple example of a subcurrency which implements functionality to mint and send a token. It is a ledger-based token, i.e. the contract maintains a ledger of user account balances.</p>
<p>Being a ledger-based token, this example does not use Fuel's <a href="examples/../blockchain-development/native_assets.html">native asset system</a>. It is not recommended to actually use ledger-based tokens in production; this example is here purely for illustrative purposes.</p>
<pre><code class="language-sway">contract;

use std::hash::sha256;

////////////////////////////////////////
// Event declarations
////////////////////////////////////////
//
// Events allow clients to react to changes in the contract.
// Unlike Solidity, events are simply structs.
//
/// Emitted when a token is sent.
struct Sent {
    from: Address,
    to: Address,
    amount: u64,
}

////////////////////////////////////////
// ABI method declarations
////////////////////////////////////////
/// ABI for a subcurrency.
abi Token {
    // Mint new tokens and send to an address.
    // Can only be called by the contract creator.
    #[storage(read, write)]
    fn mint(receiver: Address, amount: u64);

    // Sends an amount of an existing token.
    // Can be called from any address.
    #[storage(read, write)]
    fn send(receiver: Address, amount: u64);
}

////////////////////////////////////////
// Constants
////////////////////////////////////////
/// Address of contract creator.
const MINTER = Address::from(0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b);

////////////////////////////////////////
// Contract storage
////////////////////////////////////////
// Contract storage persists across transactions.
storage {
    balances: StorageMap&lt;Address, u64&gt; = StorageMap {},
}

////////////////////////////////////////
// ABI definitions
////////////////////////////////////////
/// Contract implements the `Token` ABI.
impl Token for Contract {
    #[storage(read, write)]
    fn mint(receiver: Address, amount: u64) {
        let sender = msg_sender().unwrap();
        let sender: Address = match sender {
            Identity::Address(addr) =&gt; {
                assert(addr == MINTER);
                addr
            },
            _ =&gt; revert(0),
        };

        // Increase the balance of receiver
        storage.balances.insert(receiver, storage.balances.get(receiver).try_read().unwrap_or(0) + amount);
    }

    #[storage(read, write)]
    fn send(receiver: Address, amount: u64) {
        let sender = msg_sender().unwrap();
        let sender = match sender {
            Identity::Address(addr) =&gt; addr,
            _ =&gt; revert(0),
        };

        // Reduce the balance of sender
        let sender_amount = storage.balances.get(sender).try_read().unwrap_or(0);
        assert(sender_amount &gt; amount);
        storage.balances.insert(sender, sender_amount - amount);

        // Increase the balance of receiver
        storage.balances.insert(receiver, storage.balances.get(receiver).try_read().unwrap_or(0) + amount);

        log(Sent {
            from: sender,
            to: receiver,
            amount: amount,
        });
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fizzbuzz"><a class="header" href="#fizzbuzz">FizzBuzz</a></h1>
<p>This example is not the traditional <a href="https://en.wikipedia.org/wiki/Fizz_buzz#Programming">FizzBuzz</a>; instead it is the smart contract version! A script can call the <code>fizzbuzz</code> ABI method of this contract with some <code>u64</code> value and receive back its fizzbuzzability as an <code>enum</code>.</p>
<p>The format for custom structs and enums such as <code>FizzBuzzResult</code> will be automatically included in the ABI JSON so that off-chain code can handle the encoded form of the returned data.</p>
<pre><code class="language-sway">contract;

enum FizzBuzzResult {
    Fizz: (),
    Buzz: (),
    FizzBuzz: (),
    Other: u64,
}

abi FizzBuzz {
    fn fizzbuzz(input: u64) -&gt; FizzBuzzResult;
}

impl FizzBuzz for Contract {
    fn fizzbuzz(input: u64) -&gt; FizzBuzzResult {
        if input % 15 == 0 {
            FizzBuzzResult::FizzBuzz
        } else if input % 3 == 0 {
            FizzBuzzResult::Fizz
        } else if input % 5 == 0 {
            FizzBuzzResult::Buzz
        } else {
            FizzBuzzResult::Other(input)
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet-smart-contract"><a class="header" href="#wallet-smart-contract">Wallet Smart Contract</a></h1>
<h2 id="abi-declaration"><a class="header" href="#abi-declaration">ABI Declaration</a></h2>
<pre><code class="language-sway">library;

abi Wallet {
    #[storage(read, write), payable]
    fn receive_funds();

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
}
</code></pre>
<h2 id="abi-implementation"><a class="header" href="#abi-implementation">ABI Implementation</a></h2>
<pre><code class="language-sway">contract;

use std::{
    call_frames::msg_asset_id,
    constants::BASE_ASSET_ID,
    context::msg_amount,
    token::transfer_to_address,
};

use wallet_abi::Wallet;
const OWNER_ADDRESS = Address::from(0x8900c5bec4ca97d4febf9ceb4754a60d782abbf3cd815836c1872116f203f861);

storage {
    balance: u64 = 0,
}

impl Wallet for Contract {
    #[storage(read, write), payable]
    fn receive_funds() {
        if msg_asset_id() == BASE_ASSET_ID {
            // If we received `BASE_ASSET_ID` then keep track of the balance.
            // Otherwise, we're receiving other native assets and don't care
            // about our balance of tokens.
            storage.balance.write(storage.balance.read() + msg_amount());
        }
    }

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address) {
        let sender = msg_sender().unwrap();
        match sender {
            Identity::Address(addr) =&gt; assert(addr == OWNER_ADDRESS),
            _ =&gt; revert(0),
        };

        let current_balance = storage.balance.read();
        assert(current_balance &gt;= amount_to_send);

        storage.balance.write(current_balance - amount_to_send);

        // Note: `transfer_to_address()` is not a call and thus not an
        // interaction. Regardless, this code conforms to
        // checks-effects-interactions to avoid re-entrancy.
        transfer_to_address(amount_to_send, BASE_ASSET_ID, recipient_address);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-program-types"><a class="header" href="#sway-program-types">Sway Program Types</a></h1>
<!-- This section should explain program types -->
<!-- programs:example:start -->
<p>A Sway program itself has a type: it is either a <em>contract</em>, a <em>predicate</em>, a <em>script</em>, or a <em>library</em>. The first three of these things are all deployable to the blockchain. A <em>library</em> is simply a project designed for code reuse and is never directly deployed to the chain.</p>
<p>Every Sway file <em>must</em> begin with a declaration of what type of program it is. A project can have many libraries within it, but only one contract, script, or predicate. Scripts and predicates require <code>main</code> functions to serve as entry points, while contracts instead publish an ABI. This chapter will go into detail about all of these various types of programs and what purposes they serve.</p>
<!-- programs:example:end -->
<p>Contracts are used primarily for protocols or systems that operate within a fixed set of rules. A good example would be a staking contract or a decentralized exchange.</p>
<p>Scripts are used for complex on-chain interactions that won't persist. An example of this may be using a DEX and Lender to create a leveraged position (borrow, swap, re-collateralize, borrow) which is a complex transaction that would usually take multiple steps.</p>
<p>Libraries are for code that is reusable and useful for handling common situations. A good example of this would be a library to handle fixed-point math or big number math.</p>
<ul>
<li><a href="sway-program-types/./smart_contracts.html">Contracts</a></li>
<li><a href="sway-program-types/./libraries.html">Libraries</a></li>
<li><a href="sway-program-types/./scripts.html">Scripts</a></li>
<li><a href="sway-program-types/./predicates.html">Predicates</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-smart-contract"><a class="header" href="#what-is-a-smart-contract">What is a Smart Contract?</a></h1>
<!-- This section should explain what is a smart contract -->
<!-- contract:example:start -->
<p>A smart contract is no different than a script or predicate in that it is a piece of bytecode that is deployed to the blockchain via a <a href="https://fuellabs.github.io/fuel-specs/master/protocol/tx_format">transaction</a>. The main features of a smart contract that differentiate it from scripts or predicates are that it is <em>callable</em> and <em>stateful</em>. Put another way, a smart contract is analogous to a deployed API with some database state.</p>
<!-- contract:example:end -->
<p>The interface of a smart contract, also just called a contract, must be defined strictly with an <a href="sway-program-types/smart_contracts.html#the-abi-declaration">ABI declaration</a>. See <a href="sway-program-types/../examples/subcurrency.html">this contract</a> for an example.</p>
<h2 id="syntax-of-a-smart-contract"><a class="header" href="#syntax-of-a-smart-contract">Syntax of a Smart Contract</a></h2>
<p>As with any Sway program, the program starts with a declaration of what <a href="sway-program-types/./index.html">program type</a> it is. A contract must also either define or import an <a href="sway-program-types/smart_contracts.html#the-abi-declaration">ABI declaration</a> and implement it.</p>
<!-- This section should explain best practices for ABIs -->
<!-- abi:example:start -->
<p>It is considered good practice to define your ABI in a separate library and import it into your contract. This allows callers of your contract to simply import the ABI directly and use it in their scripts to call your contract.</p>
<!-- abi:example:end -->
<p>Let's take a look at an ABI declaration in a library:</p>
<pre><code class="language-sway">library;

abi Wallet {
    #[storage(read, write), payable]
    fn receive_funds();

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
}
</code></pre>
<p>Let's focus on the ABI declaration and inspect it line-by-line.</p>
<h3 id="the-abi-declaration"><a class="header" href="#the-abi-declaration">The ABI Declaration</a></h3>
<pre><code class="language-sway">abi Wallet {
    #[storage(read, write), payable]
    fn receive_funds();

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
}
</code></pre>
<hr />
<p>In the first line, <code>abi Wallet {</code>, we declare the name of this <em>Application Binary Interface</em>, or ABI. We are naming this ABI <code>Wallet</code>. To import this ABI into either a script for calling or a contract for implementing, you would use</p>
<pre><code class="language-sway">use wallet_abi::Wallet;
</code></pre>
<hr />
<p>In the second line,</p>
<pre><code class="language-sway">    #[storage(read, write), payable]
    fn receive_funds();
</code></pre>
<p>we are declaring an ABI method called <code>receive_funds</code> which, when called, should receive funds into this wallet. Note that we are simply defining an interface here, so there is no <em>function body</em> or implementation of the function. We only need to define the interface itself. In this way, ABI declarations are similar to <a href="sway-program-types/../advanced/traits.html">trait declarations</a>. This particular ABI method does not take any parameters.</p>
<hr />
<p>In the third line,</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address);
</code></pre>
<p>we are declaring another ABI method, this time called <code>send_funds</code>. It takes two parameters: the amount to send, and the address to send the funds to.</p>
<blockquote>
<p><strong>Note</strong>: The ABI methods <code>receive_funds</code> and <code>send_funds</code> also require the annotation <code>#[storage(read, write)]</code> because their implementations require reading and writing a storage variable that keeps track of the wallet balance, as we will see shortly. Refer to <a href="sway-program-types/../blockchain-development/purity.html#Purity">Purity</a> for more information on storage annotations.</p>
</blockquote>
<h2 id="implementing-an-abi-for-a-smart-contract"><a class="header" href="#implementing-an-abi-for-a-smart-contract">Implementing an ABI for a Smart Contract</a></h2>
<p>Now that we've discussed how to define the interface, let's discuss how to use it. We will start by implementing the above ABI for a specific contract.</p>
<p>Implementing an ABI for a contract is accomplished with <code>impl &lt;ABI name&gt; for Contract</code> syntax. The <code>for Contract</code> syntax can only be used to implement an ABI for a contract; implementing methods for a struct should use <code>impl Foo</code> syntax.</p>
<pre><code class="language-sway">impl Wallet for Contract {
    #[storage(read, write), payable]
    fn receive_funds() {
        if msg_asset_id() == BASE_ASSET_ID {
            // If we received `BASE_ASSET_ID` then keep track of the balance.
            // Otherwise, we're receiving other native assets and don't care
            // about our balance of tokens.
            storage.balance.write(storage.balance.read() + msg_amount());
        }
    }

    #[storage(read, write)]
    fn send_funds(amount_to_send: u64, recipient_address: Address) {
        let sender = msg_sender().unwrap();
        match sender {
            Identity::Address(addr) =&gt; assert(addr == OWNER_ADDRESS),
            _ =&gt; revert(0),
        };

        let current_balance = storage.balance.read();
        assert(current_balance &gt;= amount_to_send);

        storage.balance.write(current_balance - amount_to_send);

        // Note: `transfer_to_address()` is not a call and thus not an
        // interaction. Regardless, this code conforms to
        // checks-effects-interactions to avoid re-entrancy.
        transfer_to_address(amount_to_send, BASE_ASSET_ID, recipient_address);
    }
}
</code></pre>
<p>You may notice once again the similarities between <a href="sway-program-types/../advanced/traits.html">traits</a> and ABIs. And, indeed, as a bonus, you can specify methods in addition to the interface surface of an ABI, just like a trait. By implementing the methods in the interface surface, you get the extra method implementations For Free™.</p>
<p>Note that the above implementation of the ABI follows the <a href="https://docs.soliditylang.org/en/v0.6.11/security-considerations.html#re-entrancy">Checks, Effects, Interactions</a> pattern.</p>
<h2 id="calling-a-smart-contract-from-a-script"><a class="header" href="#calling-a-smart-contract-from-a-script">Calling a Smart Contract from a Script</a></h2>
<blockquote>
<p><strong>Note</strong>: In most cases, calling a contract should be done from the <a href="sway-program-types/../testing/testing-with-rust.html">Rust SDK</a> or the <a href="sway-program-types/../frontend/typescript_sdk.html">TypeScript SDK</a> which provide a more ergonomic UI for interacting with a contract. However, there are situations where manually writing a script to call a contract is required.</p>
</blockquote>
<p>Now that we have defined our interface and implemented it for our contract, we need to know how to actually <em>call</em> our contract. Let's take a look at a contract call:</p>
<pre><code class="language-sway">script;

use std::constants::ZERO_B256;
use wallet_abi::Wallet;

fn main() {
    let contract_address = 0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b;
    let caller = abi(Wallet, contract_address);
    let amount_to_send = 200;
    let recipient_address = Address::from(0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b);
    caller.send_funds {
        gas: 10000,
        coins: 0,
        asset_id: ZERO_B256,
    }(amount_to_send, recipient_address);
}
</code></pre>
<p>The main new concept is the <em>abi cast</em>: <code>abi(AbiName, contract_address)</code>. This returns a <code>ContractCaller</code> type which can be used to call contracts. The methods of the ABI become the methods available on this contract caller: <code>send_funds</code> and <code>receive_funds</code>. We then directly call the contract ABI method as if it was just a regular method. You also have the option of specifying the following special parameters inside curly braces right before the main list of parameters:</p>
<ol>
<li><code>gas</code>: a <code>u64</code> that represents the gas being forwarded to the contract when it is called.</li>
<li><code>coins</code>: a <code>u64</code> that represents how many coins are being forwarded with this call.</li>
<li><code>asset_id</code>: a <code>b256</code> that represents the ID of the <em>asset type</em> of the coins being forwarded.</li>
</ol>
<p>Each special parameter is optional and assumes a default value when skipped:</p>
<ol>
<li>The default value for <code>gas</code> is the context gas (i.e. the content of the special register <code>$cgas</code>). Refer to the <a href="https://fuellabs.github.io/fuel-specs/master/vm">FuelVM specifications</a> for more information about context gas.</li>
<li>The default value for <code>coins</code> is 0.</li>
<li>The default value for <code>asset_id</code> is <code>ZERO_B256</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<!-- This section should explain what a library is -->
<!-- library:example:start -->
<p>Libraries in Sway are files used to define new common behavior.</p>
<!-- library:example:end -->
<p>The most prominent example of this is the <a href="sway-program-types/../introduction/standard_library.html">Sway Standard Library</a> that is made implicitly available to all Forc projects created using <code>forc new</code>.</p>
<h2 id="writing-libraries"><a class="header" href="#writing-libraries">Writing Libraries</a></h2>
<!-- This section should explain how libraries are defined -->
<!-- def_lib:example:start -->
<p>Libraries are defined using the <code>library</code> keyword at the beginning of a file, followed by a name so that they can be imported.</p>
<!-- def_lib:example:end -->
<pre><code class="language-sway">library;

// library code
</code></pre>
<p>A good reference library to use when learning library design is the <a href="sway-program-types/../introduction/standard_library.html">Sway Standard Library</a>. For example, the standard library offers an <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/option.sw">implementation</a> of <code>enum Option&lt;T&gt;</code> which is a generic type that represents either the existence of a value using the variant <code>Some(..)</code> or a value's absence using the variant <code>None</code>. The <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/option.sw">Sway file implementing <code>Option&lt;T&gt;</code></a> has the following structure:</p>
<ul>
<li>The <code>library</code> keyword:</li>
</ul>
<pre><code class="language-sway">library;
</code></pre>
<ul>
<li>A <code>use</code> statement that imports <code>revert</code> from another library <em>inside</em> the standard library:</li>
</ul>
<pre><code class="language-sway">use ::revert::revert;
</code></pre>
<ul>
<li>The <code>enum</code> definition which starts with the keyword <code>pub</code> to indicate that this <code>Option&lt;T&gt;</code> is publically available <em>outside</em> the <code>option</code> library:</li>
</ul>
<pre><code class="language-sway">pub enum Option&lt;T&gt; {
    // variants
}
</code></pre>
<ul>
<li>An <code>impl</code> block that implements some methods for <code>Option&lt;T&gt;</code>:</li>
</ul>
<pre><code class="language-sway">impl&lt;T&gt; Option&lt;T&gt; {

    fn is_some(self) -&gt; bool {
        // body of is_some
    }

    // other methods
}
</code></pre>
<p>Now that the library <code>option</code> is fully written, and because <code>Option&lt;T&gt;</code> is defined with the <code>pub</code> keyword, we are now able to import <code>Option&lt;T&gt;</code> using <code>use std::option::Option;</code> from any Sway project and have access to all of its variants and methods. That being said, <code>Option</code> is automatically available in the <a href="sway-program-types/../introduction/standard_library.html#standard-library-prelude">standard library prelude</a> so you never actually have to import it manually.</p>
<p>Libraries are composed of just a <code>Forc.toml</code> file and a <code>src</code> directory, unlike contracts which usually contain a <code>tests</code> directory and a <code>Cargo.toml</code> file as well. An example of a library's <code>Forc.toml</code>:</p>
<pre><code class="language-toml">[project]
authors = [&quot;Fuel Labs &lt;contact@fuel.sh&gt;&quot;]
entry = &quot;lib.sw&quot;
license = &quot;Apache-2.0&quot;
name = &quot;my_library&quot;

[dependencies]
</code></pre>
<p>which denotes the authors, an entry file, the name by which it can be imported, and any dependencies.</p>
<p>For large libraries, it is recommended to have a <code>lib.sw</code> entry point re-export all other sub-libraries.</p>
<!-- This section should explain the `mod` keyword -->
<!-- mod:example:start -->
<p>The <code>mod</code> keyword registers a submodule, making its items (such as functions and structs) accessible from the parent library.
If used at the top level it will refer to a file in the <code>src</code> folder and in other cases in a folder named after the library in which it is defined.</p>
<!-- mod:example:end -->
<p>For example, the <code>lib.sw</code> of the standard library looks like:</p>
<pre><code class="language-sway">library;

mod block;
mod storage;
mod constants;
mod vm;
// .. Other deps
</code></pre>
<p>with other libraries contained in the <code>src</code> folder, like the vm library (inside of <code>src/vm.sw</code>):</p>
<pre><code class="language-sway">library;

mod evm;
// ...
</code></pre>
<p>and it's own sub-library evm located in <code>src/vm/evm.sw</code>:</p>
<pre><code class="language-sway">library;

// ...
</code></pre>
<h2 id="using-libraries"><a class="header" href="#using-libraries">Using Libraries</a></h2>
<p>There are two types of Sway libraries, based on their location and how they can be imported.</p>
<h3 id="internal-libraries"><a class="header" href="#internal-libraries">Internal Libraries</a></h3>
<p>Internal libraries are located within the project's <code>src</code> directory alongside
<code>main.sw</code> or in the appropriate folders as shown below:</p>
<pre><code class="language-bash">$ tree
.
├── Cargo.toml
├── Forc.toml
└── src
    ├── internal_lib.sw
    ├── main.sw
    └── internal_lib
        └── nested_lib.sw
</code></pre>
<p>As <code>internal_lib</code> is an internal library, it can be imported into <code>main.sw</code> as follows:</p>
<ul>
<li>Use the <code>mod</code> keyword followed by the library name to make the internal library a dependancy</li>
<li>Use the <code>use</code> keyword with a <code>::</code> separating the name of the library and the imported item(s)</li>
</ul>
<pre><code class="language-sway">mod internal_lib; // Assuming the library name in `internal_lib.sw` is `internal_lib`

use internal_lib::mint;

// `mint` from `internal_library` is now available in this file
</code></pre>
<h3 id="external-libraries"><a class="header" href="#external-libraries">External Libraries</a></h3>
<p>External libraries are located outside the main <code>src</code> directory as shown below:</p>
<pre><code class="language-bash">$ tree
.
├── my_project
│   ├── Cargo.toml
│   ├── Forc.toml
│   └─── src
│       └── main.sw
│
└── external_lib
    ├── Cargo.toml
    ├── Forc.toml
    └─── src
        └── lib.sw
</code></pre>
<p>As <code>external_lib</code> is outside the <code>src</code> directory of <code>my_project</code>, it needs to be added as a dependency in the <code>Forc.toml</code> file of <code>my_project</code>, by adding the library path in the <code>dependencies</code> section as shown below, before it can be imported:</p>
<pre><code class="language-toml">[dependencies]
external_library = { path = &quot;../external_library&quot; }
</code></pre>
<p>Once the library dependency is added to the <code>toml</code> file, you can import items from it as follows:</p>
<ul>
<li>Make sure the item you want imported are declared with the <code>pub</code> keyword (if applicable, for instance: <code>pub fn mint() {}</code>)</li>
<li>Use the <code>use</code> keyword to selectively import items from the library</li>
</ul>
<pre><code class="language-sway">use external_library::mint;

// `mint` from `external_library` is now available in this file
</code></pre>
<p>Wildcard imports using <code>*</code> are supported, but it is generally recommended to use explicit imports where possible.</p>
<blockquote>
<p><strong>Note</strong>: the standard library is implicitly available to all Forc projects, that is, you are not required to manually specify <code>std</code> as an explicit dependency in <code>Forc.toml</code>.</p>
</blockquote>
<h2 id="reference-sway-libraries"><a class="header" href="#reference-sway-libraries">Reference Sway Libraries</a></h2>
<p>The repository <a href="https://github.com/FuelLabs/sway-libs/"><code>sway-libs</code></a> is a collection of external libraries that you can import and make use of in your Fuel applications. These libraries are meant to be learning references of common use-cases valuable for dapp development.</p>
<p>Some Sway Libraries to try out:</p>
<ul>
<li><a href="https://github.com/FuelLabs/sway-libs/tree/master/libs/merkle_proof">Binary Merkle Proof</a></li>
<li><a href="https://github.com/FuelLabs/sway-libs/tree/master/libs/nft">Non-Fungible Token</a></li>
<li><a href="https://github.com/FuelLabs/sway-libs/tree/master/libs/string">String</a></li>
<li><a href="https://github.com/FuelLabs/sway-libs/tree/master/libs/signed_integers">Signed Integers</a></li>
<li><a href="https://github.com/FuelLabs/sway-libs/tree/master/libs/fixed_point">Unsigned Fixed Point Number</a></li>
<li><a href="https://github.com/FuelLabs/sway-libs/tree/master/libs/storagemapvec">StorageMapVec</a></li>
</ul>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>You can import and use a Sway Library such as the <a href="https://github.com/FuelLabs/sway-libs/tree/master/sway_libs/src/nft">NFT</a> library just like any other external library.</p>
<pre><code class="language-sway">use sway_libs::nft::{
    mint,
    transfer,
    owner_of,
    approve,
};
</code></pre>
<p>Once imported, you can use the following basic functionality of the library in your smart contract:</p>
<ul>
<li>Minting tokens</li>
<li>Transfering tokens</li>
<li>Retrieving owner of a token</li>
<li>Approving users to transfer a token</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripts"><a class="header" href="#scripts">Scripts</a></h1>
<p>A script is runnable bytecode on the chain which executes once to perform some task. It does not represent ownership of any resources and it cannot be called by a contract. A script can return a single value of any type.</p>
<p>Scripts are state-aware in that while they have no persistent storage (because they only exist during the transaction) they can call contracts and act based upon the returned values and results.</p>
<p>This example script calls a contract:</p>
<pre><code class="language-sway">script;

use std::constants::ZERO_B256;
use wallet_abi::Wallet;

fn main() {
    let contract_address = 0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b;
    let caller = abi(Wallet, contract_address);
    let amount_to_send = 200;
    let recipient_address = Address::from(0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b);
    caller.send_funds {
        gas: 10000,
        coins: 0,
        asset_id: ZERO_B256,
    }(amount_to_send, recipient_address);
}
</code></pre>
<p>Scripts, similar to predicates, rely on a <code>main()</code> function as an entry point. You can call other functions defined in a script from the <code>main()</code> function or call another contract via an <a href="sway-program-types/./smart_contracts.html#calling-a-smart-contract-from-a-script">abi cast</a>.</p>
<p>An example use case for a script would be a router that trades funds through multiple DEXes to get the price for the input asset, or a script to re-adjust a Collateralized Debt Position via a flashloan.</p>
<h2 id="scripts-and-the-sdks"><a class="header" href="#scripts-and-the-sdks">Scripts and the SDKs</a></h2>
<p>Unlike EVM transactions which can call a contract directly (but can only call a single contract), Fuel transactions execute a script, which may call zero or more contracts. The Rust and TypeScript SDKs provide functions to call contract methods as if they were calling contracts directly. Under the hood, the SDKs wrap all contract calls with scripts that contain minimal code to simply make the call and forward script data as call parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicates"><a class="header" href="#predicates">Predicates</a></h1>
<p>From the perspective of Sway, predicates are programs that return a Boolean value and which represent ownership of some resource upon execution to true. They have no access to contract storage. Here is a trivial predicate, which always evaluates to true:</p>
<pre><code class="language-sway">predicate;

// All predicates require a main function which returns a Boolean value.
fn main() -&gt; bool {
    true
}
</code></pre>
<h2 id="debugging-predicates"><a class="header" href="#debugging-predicates">Debugging Predicates</a></h2>
<p>Because they don't have any side effects (they are <em>pure</em>), predicates cannot create receipts. Therefore, they cannot have logging or create a stack backtrace. This means that there is no native way to debug them aside from using a single-stepping debugger (which is a <a href="https://github.com/FuelLabs/fuel-debugger/pull/1">work-in-progress</a>).</p>
<p>As a workaround, the predicate can be written, tested, and debugged first as a <code>script</code>, and then changed back into a <code>predicate</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-language-basics"><a class="header" href="#sway-language-basics">Sway Language basics</a></h1>
<p>Sway is a programming language designed for the FuelVM. It is a statically typed, compiled language with type inference and traits. Sway aims to make smart contract development safer and more performant through the use of strong static analysis and compiler feedback.</p>
<p>Get started with the basics of Sway:</p>
<ul>
<li><a href="basics/./variables.html">Variables</a></li>
<li><a href="basics/./built_in_types.html">Built-in Types</a></li>
<li><a href="basics/./commonly_used_library_types.html">Commonly Used Library Types</a></li>
<li><a href="basics/./blockchain_types.html">Blockchain Types</a></li>
<li><a href="basics/./functions.html">Functions</a></li>
<li><a href="basics/./structs_tuples_and_enums.html">Structs, Tuples, and Enums</a></li>
<li><a href="basics/./methods_and_associated_functions.html">Methods and Associated Functions</a></li>
<li><a href="basics/./constants.html">Constants</a></li>
<li><a href="basics/./comments_and_logging.html">Comments and Logging</a></li>
<li><a href="basics/./control_flow.html">Control Flow</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<!-- This section should explain how variables are immutable -->
<!-- immutable_vars:example:start -->
<p>Variables in Sway are <em>immutable by default</em>. This means that, by default, once a variable is declared, its value cannot change. This is one of the ways how Sway encourages safe programming, and many modern languages have this same default.</p>
<!-- immutable_vars:example:end -->
<p>Let's take a look at variables in detail.</p>
<h2 id="declaring-a-variable"><a class="header" href="#declaring-a-variable">Declaring a Variable</a></h2>
<p>Let's look at a variable declaration:</p>
<pre><code class="language-sway">let foo = 5;
</code></pre>
<p>Great! We have just declared a variable, <code>foo</code>. What do we know about <code>foo</code>?</p>
<ol>
<li>It is immutable.</li>
<li>Its value is <code>5</code>.</li>
<li>Its type is <code>u64</code>, a 64-bit unsigned integer.</li>
</ol>
<p><code>u64</code> is the default numeric type, and represents a 64-bit unsigned integer. See the section <a href="basics/./built_in_types.html">Built-in Types</a> for more details.</p>
<p>We can also make a mutable variable. Let's take a look:</p>
<pre><code class="language-sway">let mut foo = 5;
foo = 6;
</code></pre>
<p>Now, <code>foo</code> is mutable, and the reassignment to the number <code>6</code> is valid. That is, we are allowed to <em>mutate</em> the variable <code>foo</code> to change its value.</p>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h2>
<!-- This section should explain type annotations -->
<!-- type_annotations:example:start -->
<p>A variable declaration can contain a <em>type annotation</em>. A type annotation serves the purpose of declaring the type, in addition to the value, of a variable.</p>
<!-- type_annotations:example:end -->
<p>Let's take a look:</p>
<pre><code class="language-sway">let foo: u32 = 5;
</code></pre>
<p>We have just declared the <em>type</em> of the variable <code>foo</code> as a <code>u32</code>, which is an unsigned 32-bit integer. Let's take a look at a few other type annotations:</p>
<pre><code class="language-sway">let bar: str[4] = &quot;sway&quot;;
let baz: bool = true;
</code></pre>
<!-- This section should explain what happens if there is a type conflict -->
<!-- type_conflict:example:start -->
<p>If the value declared cannot be assigned to the declared type, there will be an error generated by the compiler.</p>
<!-- type_conflict:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h1>
<p>Every value in Sway is of a certain type. Although deep down, all values are just ones and zeroes in the underlying virtual machine, Sway needs to know what those ones and zeroes actually mean. This is accomplished with <em>types</em>.</p>
<!-- This section should explain how Sway types are inferred -->
<!-- sway_types:example:start -->
<p>Sway is a statically typed language. At compile time, the types of every value must be known. This does not mean you need to specify every single type: usually, the type can be reasonably inferred by the compiler.</p>
<!-- sway_types:example:end -->
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<!-- This section should list the primitive types in Sway -->
<!-- prim_types:example:start -->
<p>Sway has the following primitive types:</p>
<ol>
<li><code>u8</code> (8-bit unsigned integer)</li>
<li><code>u16</code> (16-bit unsigned integer)</li>
<li><code>u32</code> (32-bit unsigned integer)</li>
<li><code>u64</code> (64-bit unsigned integer)</li>
<li><code>str[]</code> (fixed-length string)</li>
<li><code>bool</code> (Boolean <code>true</code> or <code>false</code>)</li>
<li><code>b256</code> (256 bits (32 bytes), i.e. a hash)</li>
</ol>
<p>All other types in Sway are built up of these primitive types, or references to these primitive types. You may notice that there are no signed integers—this is by design. In the blockchain domain that Sway occupies, floating-point values and negative numbers have smaller utility, so their implementation has been left up to libraries for specific use cases.</p>
<!-- prim_types:example:end -->
<h2 id="numeric-types"><a class="header" href="#numeric-types">Numeric Types</a></h2>
<p>All of the unsigned integer types are numeric types.</p>
<p>Numbers can be declared with binary syntax, hexadecimal syntax, base-10 syntax, and underscores for delineation. Let's take a look at the following valid numeric primitives:</p>
<pre><code class="language-sway">0xffffff    // hexadecimal
0b10101010  // binary
10          // base-10
100_000     // underscore delineated base-10
0x1111_0000 // underscore delineated binary
0xfff_aaa   // underscore delineated hexadecimal
</code></pre>
<!-- This section should explain the default numeric type in Sway -->
<!-- default_num:example:start -->
<p>The default numeric type is <code>u64</code>. The FuelVM's word size is 64 bits, and the cases where using a smaller numeric type saves space are minimal.</p>
<p>If a 64-bit arithmetic operation produces an overflow or an underflow,
computation gets reverted automatically by FuelVM.</p>
<p>8/16/32-bit arithmetic operations are emulated using their 64-bit analogues with
additional overflow/underflow checks inserted, which generally results in
somewhat higher gas consumption.</p>
<!-- default_num:example:end -->
<h2 id="boolean-type"><a class="header" href="#boolean-type">Boolean Type</a></h2>
<!-- This section should explain the `bool` type -->
<!-- bool:example:start -->
<p>The boolean type (<code>bool</code>) has two potential values: <code>true</code> or <code>false</code>. Boolean values are typically used for conditional logic or validation, for example in <code>if</code> expressions. Booleans can be negated, or flipped, with the unary negation operator <code>!</code>.</p>
<!-- bool:example:end -->
<p>For example:</p>
<pre><code class="language-sway">fn returns_false() -&gt; bool {
    let boolean_value: bool = true;
    !boolean_value
}
</code></pre>
<h2 id="string-type"><a class="header" href="#string-type">String Type</a></h2>
<!-- This section should explain the string type in Sway -->
<!-- str:example:start -->
<p>In Sway, static-length strings are a primitive type. This means that when you declare a string, its size is a part of its type. This is necessary for the compiler to know how much memory to give for the storage of that data. The size of the string is denoted with square brackets.</p>
<!-- str:example:end -->
<p>Let's take a look:</p>
<pre><code class="language-sway">let my_string: str[4] = &quot;fuel&quot;;
</code></pre>
<p>Because the string literal <code>&quot;fuel&quot;</code> is four letters, the type is <code>str[4]</code>, denoting a static length of 4 characters. Strings default to UTF-8 in Sway.</p>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<p><em>Compound types</em> are types that group multiple values into one type. In Sway, we have arrays and tuples.</p>
<h2 id="tuple-types"><a class="header" href="#tuple-types">Tuple Types</a></h2>
<!-- This section should explain what a tuple is -->
<!-- tuple:example:start -->
<p>A tuple is a general-purpose static-length aggregation of types. In more plain terms, a tuple is a single type that consists of an aggregate of zero or more types. The internal types that make up a tuple, and the tuple's arity, define the tuple's type.</p>
<!-- tuple:example:end -->
<p>Let's take a look at some examples.</p>
<pre><code class="language-sway">let x: (u64, u64) = (0, 0);
</code></pre>
<p>This is a tuple, denoted by parenthesized, comma-separated values. Note that the type annotation, <code>(u64, u64)</code>, is similar in syntax to the expression which instantiates that type, <code>(0, 0)</code>.</p>
<pre><code class="language-sway">let x: (u64, bool) = (42, true);
assert(x.1);
</code></pre>
<p>In this example, we have created a new tuple type, <code>(u64, bool)</code>, which is a composite of a <code>u64</code> and a <code>bool</code>.</p>
<!-- This section should explain how to access a value in a tuple -->
<!-- tuple_val:example:start -->
<p>To access a value within a tuple, we use <em>tuple indexing</em>: <code>x.1</code> stands for the first (zero-indexed, so the <code>bool</code>) value of the tuple. Likewise, <code>x.0</code> would be the zeroth, <code>u64</code> value of the tuple. Tuple values can also be accessed via destructuring.</p>
<!-- tuple_val:example:end -->
<pre><code class="language-sway">struct Foo {}
let x: (u64, Foo, bool) = (42, Foo {}, true);
let (number, foo, boolean) = x;
</code></pre>
<p>To create one-arity tuples, we will need to add a trailing comma:</p>
<pre><code class="language-sway">let x: u64 = (42);     // x is of type u64
let y: (u64) = (42);   // y is of type u64
let z: (u64,) = (42,); // z is of type (u64), i.e. a one-arity tuple
let w: (u64) = (42,);  // type error
</code></pre>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<!-- This section should explain what an array is -->
<!-- array:example:start -->
<p>An array is similar to a tuple, but an array's values must all be of the same type. Arrays can hold arbitrary types including non-primitive types.</p>
<!-- array:example:end -->
<p>An array is written as a comma-separated list inside square brackets:</p>
<pre><code class="language-sway">let x = [1, 2, 3, 4, 5];
</code></pre>
<!-- This section should explain arrays in depth -->
<!-- array_details:example:start -->
<p>Arrays are allocated on the stack since their size is known. An array's size is <em>always</em> static, i.e. it cannot change. An array of five elements cannot become an array of six elements.</p>
<p>Arrays can be iterated over, unlike tuples. An array's type is written as the type the array contains followed by the number of elements, semicolon-separated and within square brackets, e.g. <code>[u64; 5]</code>. To access an element in an array, use the <em>array indexing syntax</em>, i.e. square brackets.</p>
<!-- array_details:example:end -->
<p>Array elements can also be mutated if the underlying array is declared as mutable:</p>
<pre><code class="language-sway">let mut x = [1, 2, 3, 4, 5];
x[0] = 0;
</code></pre>
<pre><code class="language-sway">script;

struct Foo {
    f1: u32,
    f2: b256,
}

fn main() {
    // Array of integers with type ascription
    let array_of_integers: [u8; 5] = [1, 2, 3, 4, 5];

    // Array of strings
    let array_of_strings = [&quot;Bob&quot;, &quot;Jan&quot;, &quot;Ron&quot;];

    // Array of structs
    let array_of_structs: [Foo; 2] = [
        Foo {
            f1: 11,
            f2: 0x1111111111111111111111111111111111111111111111111111111111111111,
        },
        Foo {
            f1: 22,
            f2: 0x2222222222222222222222222222222222222222222222222222222222222222,
        },
    ];

    // Accessing an element of an array
    let mut array_of_bools: [bool; 2] = [true, false];
    assert(array_of_bools[0]);

    // Mutating the element of an array
    array_of_bools[1] = true;
    assert(array_of_bools[1]);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commonly-used-library-types"><a class="header" href="#commonly-used-library-types">Commonly Used Library Types</a></h1>
<p>The Sway Standard Library is the foundation of portable Sway software, a set of minimal shared abstractions for the broader Sway ecosystem. It offers core types, library-defined operations on language primitives, native asset management, blockchain contextual operations, access control, storage management, and support for types from other VMs, among many other things. Reference the standard library docs <a href="https://fuellabs.github.io/sway/master/std/index.html">here</a>.</p>
<h2 id="resultt-e"><a class="header" href="#resultt-e"><code>Result&lt;T, E&gt;</code></a></h2>
<!-- This section should explain what the `Result` type is -->
<!-- result:example:start -->
<p>Type <code>Result</code> is the type used for returning and propagating errors. It is an <code>enum</code> with two variants: <code>Ok(T)</code>, representing success and containing a value, and <code>Err(E)</code>, representing error and containing an error value. The <code>T</code> and <code>E</code> in this definition are type parameters, allowing <code>Result</code> to be generic and to be used with any types.</p>
<!-- result:example:end -->
<pre><code class="language-sway">/// `Result` is a type that represents either success (`Ok`) or failure (`Err`).
pub enum Result&lt;T, E&gt; {
    /// Contains the success value.
    Ok: T,
    /// Contains the error value.
    Err: E,
}
</code></pre>
<!-- This section should explain when to use the `Result` type -->
<!-- use_result:example:start -->
<p>Functions return <code>Result</code> whenever errors are expected and recoverable.</p>
<!-- use_result:example:end -->
<p>Take the following example:</p>
<pre><code class="language-sway">script;

enum MyContractError {
    DivisionByZero: (),
}

fn divide(numerator: u64, denominator: u64) -&gt; Result&lt;u64, MyContractError&gt; {
    if (denominator == 0) {
        return Err(MyContractError::DivisionByZero);
    } else {
        Ok(numerator / denominator)
    }
}

fn main() -&gt; Result&lt;u64, str[4]&gt; {
    let result = divide(20, 2);
    match result {
        Ok(value) =&gt; Ok(value),
        Err(MyContractError::DivisionByZero) =&gt; Err(&quot;Fail&quot;),
    }
}
</code></pre>
<h2 id="optiont"><a class="header" href="#optiont"><code>Option&lt;T&gt;</code></a></h2>
<!-- This section should explain the `Option` type -->
<!-- option:example:start -->
<p>Type <code>Option</code> represents an optional value: every <code>Option</code> is either <code>Some</code> and contains a value, or <code>None</code>, and does not. <code>Option</code> types are very common in Sway code, as they have a number of uses:</p>
<ul>
<li>Initial values where <code>None</code> can be used as an initializer.</li>
<li>Return value for otherwise reporting simple errors, where <code>None</code> is returned on error.</li>
</ul>
<p>The implementation of <code>Option</code> matches on the variant: if it's <code>Ok</code> it returns the inner value, if it's <code>None</code>, it <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/vm/instruction_set.md#rvrt-revert">reverts</a>.</p>
<!-- option:example:end -->
<pre><code class="language-sway">/// A type that represents an optional value, either `Some(val)` or `None`.
pub enum Option&lt;T&gt; {
    /// No value.
    None: (),
    /// Some value of type `T`.
    Some: T,
}
</code></pre>
<!-- This section should explain when to use the `Option` type -->
<!-- use_option:example:start -->
<p><code>Option</code> is commonly paired with pattern matching to query the presence of a value and take action, allowing developers to choose how to handle the <code>None</code> case.</p>
<!-- use_option:example:end -->
<p>Below is an example that uses pattern matching to handle invalid divisions by 0 by returning an <code>Option</code>:</p>
<pre><code class="language-sway">script;

fn divide(numerator: u64, denominator: u64) -&gt; Option&lt;u64&gt; {
    if denominator == 0 {
        None
    } else {
        Some(numerator / denominator)
    }
}

fn main() {
    let result = divide(6, 2);
    // Pattern match to retrieve the value
    match result {
        // The division was valid
        Some(x) =&gt; std::logging::log(x),
        // The division was invalid
        None =&gt; std::logging::log(&quot;Cannot divide by 0&quot;),
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-types"><a class="header" href="#blockchain-types">Blockchain Types</a></h1>
<p>Sway is fundamentally a blockchain language, and it offers a selection of types tailored for the blockchain use case.</p>
<p>These are provided via the standard library (<a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std"><code>lib-std</code></a>) which both add a degree of type-safety, as well as make the intention of the developer more clear.</p>
<h2 id="address-type"><a class="header" href="#address-type"><code>Address</code> Type</a></h2>
<!-- This section should explain the `Address` type -->
<!-- address:example:start -->
<p>The <code>Address</code> type is a type-safe wrapper around the primitive <code>b256</code> type. Unlike the EVM, an address <strong>never</strong> refers to a deployed smart contract (see the <code>ContractId</code> type below). An <code>Address</code> can be either the hash of a public key (effectively an <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts">externally owned account</a> if you're coming from the EVM) or the hash of a <a href="basics/../sway-program-types/predicates.html">predicate</a>. Addresses own UTXOs.</p>
<!-- address:example:end -->
<p>An <code>Address</code> is implemented as follows.</p>
<pre><code class="language-sway">pub struct Address {
    value: b256,
}
</code></pre>
<p>Casting between the <code>b256</code> and <code>Address</code> types must be done explicitly:</p>
<pre><code class="language-sway">let my_number: b256 = 0x000000000000000000000000000000000000000000000000000000000000002A;
let my_address: Address = Address::from(my_number);
let forty_two: b256 = my_address.into();
</code></pre>
<h2 id="contractid-type"><a class="header" href="#contractid-type"><code>ContractId</code> Type</a></h2>
<!-- This section should explain the `ContractId` type -->
<!-- contract_id:example:start -->
<p>The <code>ContractId</code> type is a type-safe wrapper around the primitive <code>b256</code> type. A contract's ID is a unique, deterministic identifier analogous to a contract's address in the EVM. Contracts cannot own UTXOs but can own assets.</p>
<!-- contract_id:example:end -->
<p>A <code>ContractId</code> is implemented as follows.</p>
<pre><code class="language-sway">pub struct ContractId {
    value: b256,
}
</code></pre>
<p>Casting between the <code>b256</code> and <code>ContractId</code> types must be done explicitly:</p>
<pre><code class="language-sway">let my_number: b256 = 0x000000000000000000000000000000000000000000000000000000000000002A;
let my_contract_id: ContractId = ContractId::from(my_number);
let forty_two: b256 = my_contract_id.into();
</code></pre>
<h2 id="identity-type"><a class="header" href="#identity-type"><code>Identity</code> Type</a></h2>
<!-- This section should explain the `Identity` type -->
<!-- identity:example:start -->
<p>The <code>Identity</code> type is an enum that allows for the handling of both <code>Address</code> and <code>ContractId</code> types. This is useful in cases where either type is accepted, e.g. receiving funds from an identified sender, but not caring if the sender is an address or a contract.</p>
<!-- identity:example:end -->
<p>An <code>Identity</code> is implemented as follows.</p>
<pre><code class="language-sway">pub enum Identity {
    Address: Address,
    ContractId: ContractId,
}
</code></pre>
<p>Casting to an <code>Identity</code> must be done explicitly:</p>
<pre><code class="language-sway">        let raw_address: b256 = 0xddec0e7e6a9a4a4e3e57d08d080d71a299c628a46bc609aab4627695679421ca;
        let my_identity: Identity = Identity::Address(Address::from(raw_address));
</code></pre>
<p>A <code>match</code> statement can be used to return to an <code>Address</code> or <code>ContractId</code> as well as handle cases in which their execution differs.</p>
<pre><code class="language-sway">        let my_contract_id: ContractId = match my_identity {
            Identity::ContractId(identity) =&gt; identity,
            _ =&gt; revert(0),
        };
</code></pre>
<pre><code class="language-sway">        match my_identity {
            Identity::Address(address) =&gt; transfer_to_address(amount, token_id, address),
            Identity::ContractId(contract_id) =&gt; force_transfer_to_contract(amount, token_id, contract_id),
        };
</code></pre>
<!-- This section should explain the use case for the `Identity` type -->
<!-- use_identity:example:start -->
<p>A common use case for <code>Identity</code> is for access control. The use of <code>Identity</code> uniquely allows both <code>ContractId</code> and <code>Address</code> to have access control inclusively.</p>
<!-- use_identity:example:end -->
<pre><code class="language-sway">        let sender = msg_sender().unwrap();
        require(sender == storage.owner.read(), MyError::UnauthorizedUser(sender));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions in Sway are declared with the <code>fn</code> keyword. Let's take a look:</p>
<pre><code class="language-sway">fn equals(first_param: u64, second_param: u64) -&gt; bool {
    first_param == second_param
}
</code></pre>
<p>We have just declared a function named <code>equals</code> which takes two parameters: <code>first_param</code> and <code>second_param</code>. The parameters must both be 64-bit unsigned integers.</p>
<p>This function also returns a <code>bool</code> value, i.e. either <code>true</code> or <code>false</code>. This function returns <code>true</code> if the two given parameters are equal, and <code>false</code> if they are not. If we want to use this function, we can do so like this:</p>
<pre><code class="language-sway">fn main() {
    equals(5, 5); // evaluates to `true`
    equals(5, 6); // evaluates to `false`
}
</code></pre>
<h2 id="mutable-parameters"><a class="header" href="#mutable-parameters">Mutable Parameters</a></h2>
<!-- This section should explain how/when to use `ref mut` -->
<!-- ref_mut:example:start -->
<p>We can make a function parameter mutable by adding <code>ref mut</code> before the parameter name. This allows mutating the argument passed into the function when the function is called.</p>
<!-- ref_mut:example:end -->
<p>For example:</p>
<pre><code class="language-sway">fn increment(ref mut num: u32) {
    let prev = num;
    num = prev + 1u32;
}
</code></pre>
<p>This function is allowed to mutate its parameter <code>num</code> because of the <code>mut</code> keyword. In addition, the <code>ref</code> keyword instructs the function to modify the argument passed to it when the function is called, instead of modifying a local copy of it.</p>
<pre><code class="language-sway">    let mut num: u32 = 0;
    increment(num);
    assert(num == 1u32); // The function `increment()` modifies `num`
</code></pre>
<p>Note that the variable <code>num</code> itself has to be declared as mutable for the above to compile.</p>
<blockquote>
<p><strong>Note</strong>
It is not currently allowed to use <code>mut</code> without <code>ref</code> or vice versa for a function parameter.</p>
</blockquote>
<p>Similarly, <code>ref mut</code> can be used with more complex data types such as:</p>
<pre><code class="language-sway">fn swap_tuple(ref mut pair: (u64, u64)) {
    let temp = pair.0;
    pair.0 = pair.1;
    pair.1 = temp;
}

fn update_color(ref mut color: Color, new_color: Color) {
    color = new_color;
}
</code></pre>
<p>We can then call these functions as shown below:</p>
<pre><code class="language-sway">    let mut tuple = (42, 24);
    swap_tuple(tuple);
    assert(tuple.0 == 24); // The function `swap_tuple()` modifies `tuple.0`
    assert(tuple.1 == 42); // The function `swap_tuple()` modifies `tuple.1`
    let mut color = Color::Red;
    update_color(color, Color::Blue);
    assert(match color {
        Color::Blue =&gt; true,
        _ =&gt; false,
    }); // The function `update_color()` modifies the color to Blue
</code></pre>
<blockquote>
<p><strong>Note</strong>
The only place, in a Sway program, where the <code>ref</code> keyword is valid is before a mutable function parameter.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-tuples-and-enums"><a class="header" href="#structs-tuples-and-enums">Structs, Tuples, and Enums</a></h1>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<!-- This section should explain structs in Sway -->
<!-- structs:example:start -->
<p>Structs in Sway are a named grouping of types. You may also be familiar with structs via another name: <em>product types</em>. Sway does not make any significantly unique usages of structs; they are similar to most other languages which have structs. If you're coming from an object-oriented background, a struct is like the data attributes of an object.</p>
<!-- structs:example:end -->
<p>Firstly, we declare a struct named <code>Foo</code> with two fields. The first field is named <code>bar</code> and it accepts values of type <code>u64</code>, the second field is named <code>baz</code> and it accepts <code>bool</code> values.</p>
<pre><code class="language-sway">library;

// Declare a struct type
pub struct Foo {
    bar: u64,
    baz: bool,
}

// Struct types for destructuring
pub struct Point {
    x: u64,
    y: u64,
}

pub struct Line {
    p1: Point,
    p2: Point,
}

pub struct TupleInStruct {
    nested_tuple: (u64, (u32, (bool, str[2]))),
}
</code></pre>
<!-- This section should explain how to instantiate a struct in Sway -->
<!-- new_struct:example:start -->
<p>In order to instantiate the struct we use <em>struct instantiation syntax</em>, which is very similar to the declaration syntax except with expressions in place of types.</p>
<p>There are three ways to instantiate the struct.</p>
<ul>
<li>Hardcoding values for the fields</li>
<li>Passing in variables with names different than the struct fields</li>
<li>Using a shorthand notation via variables that are the same as the field names</li>
</ul>
<!-- new_struct:example:end -->
<pre><code class="language-sway">library;

mod data_structures;
use data_structures::{Foo, Line, Point, TupleInStruct};

fn hardcoded_instantiation() -&gt; Foo {
    // Instantiate `foo` as `Foo`
    let mut foo = Foo {
        bar: 42,
        baz: false,
    };

    // Access and write to &quot;baz&quot;
    foo.baz = true;

    // Return the struct
    foo
}

fn variable_instantiation() -&gt; Foo {
    // Declare variables with the same names as the fields in `Foo`
    let number = 42;
    let truthness = false;

    // Instantiate `foo` as `Foo`
    let mut foo = Foo {
        bar: number,
        baz: truthness,
    };

    // Access and write to &quot;baz&quot;
    foo.baz = true;

    // Return the struct
    foo
}

fn shorthand_instantiation() -&gt; Foo {
    // Declare variables with the same names as the fields in `Foo`
    let bar = 42;
    let baz = false;

    // Instantiate `foo` as `Foo`
    let mut foo = Foo { bar, baz };

    // Access and write to &quot;baz&quot;
    foo.baz = true;

    // Return the struct
    foo
}

fn struct_destructuring() {
    let point1 = Point { x: 0, y: 0 };
    // Destructure the values from the struct into variables
    let Point { x, y } = point1;

    let point2 = Point { x: 1, y: 1 };
    // If you do not care about specific struct fields then use &quot;..&quot; at the end of your variable list
    let Point { x, .. } = point2;

    let line = Line {
        p1: point1,
        p2: point2,
    };
    // Destructure the values from the nested structs into variables
    let Line {
        p1: Point { x: x0, y: y0 },
        p2: Point { x: x1, y: y1 },
    } = line;
    // You may also destructure tuples nested in structs and structs nested in tuples
    let tuple_in_struct = TupleInStruct {
        nested_tuple: (42u64, (42u32, (true, &quot;ok&quot;))),
    };
    let TupleInStruct {
        nested_tuple: (a, (b, (c, d))),
    } = tuple_in_struct;

    let struct_in_tuple = (Point { x: 2, y: 4 }, Point { x: 3, y: 6 });
    let (Point { x: x0, y: y0 }, Point { x: x1, y: y1 }) = struct_in_tuple;
}
</code></pre>
<blockquote>
<p><strong>Note</strong>
You can mix and match all 3 ways to instantiate the struct at the same time.
Moreover, the order of the fields does not matter when instantiating however we encourage declaring the fields in alphabetical order and instantiating them in the same alphabetical order</p>
</blockquote>
<p>Furthermore, multiple variables can be extracted from a struct using the destructuring syntax.</p>
<h3 id="struct-memory-layout"><a class="header" href="#struct-memory-layout">Struct Memory Layout</a></h3>
<blockquote>
<p><strong>Note</strong>
This information is not vital if you are new to the language, or programming in general</p>
</blockquote>
<p>Structs have zero memory overhead. What that means is that in memory, each struct field is laid out sequentially. No metadata regarding the struct's name or other properties is preserved at runtime. In other words, structs are compile-time constructs. This is the same in Rust, but different in other languages with runtimes like Java.</p>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<!-- This section should explain what tuples are and how to access tuple values -->
<!-- tuples:example:start -->
<p>Tuples are a <a href="basics/./built_in_types.html#tuple-types">basic static-length type</a> which contain multiple different types within themselves. The type of a tuple is defined by the types of the values within it, and a tuple can contain basic types as well as structs and enums.</p>
<p>You can access values directly by using the <code>.</code> syntax. Moreover, multiple variables can be extracted from a tuple using the destructuring syntax.</p>
<!-- tuples:example:end -->
<pre><code class="language-sway">library;

fn tuple() {
    // You can declare the types youself
    let tuple1: (u8, bool, u64) = (100, false, 10000);

    // Or have the types be inferred
    let mut tuple2 = (5, true, (&quot;Sway&quot;, 8));

    // Retrieve values from tuples
    let number = tuple1.0;
    let sway = tuple2.2.1;

    // Destructure the values from the tuple into variables
    let (n1, truthness, n2) = tuple1;

    // If you do not care about specific values then use &quot;_&quot;
    let (_, truthness, _) = tuple2;

    // Internally mutate the tuple
    tuple2.1 = false;

    // Or change the values all at once (must keep the same data types)
    tuple2 = (9, false, (&quot;Fuel&quot;, 99));
}
</code></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<!-- This section should explain what enums are -->
<!-- enums:example:start -->
<p><em>Enumerations</em>, or <em>enums</em>, are also known as <em>sum types</em>. An enum is a type that could be one of several variants. To declare an enum, you enumerate all potential variants.</p>
<!-- enums:example:end -->
<p>Here, we have defined five potential colors. Each enum variant is just the color name. As there is no extra data associated with each variant, we say that each variant is of type <code>()</code>, or unit.</p>
<pre><code class="language-sway">library;

// Declare the enum
enum Color {
    Blue: (),
    Green: (),
    Red: (),
    Silver: (),
    Grey: (),
}

fn main() {
    // To instantiate a variable with the value of an enum the syntax is
    let blue = Color::Blue;
    let silver = Color::Silver;
}
</code></pre>
<h3 id="enums-of-structs"><a class="header" href="#enums-of-structs">Enums of Structs</a></h3>
<p>It is also possible to have an enum variant contain extra data. Take a look at this more substantial example, which combines struct declarations with enum variants:</p>
<pre><code class="language-sway">library;

struct Item {
    price: u64,
    amount: u64,
    id: u64,
}

enum MyEnum {
    Item: Item,
}

fn main() {
    let my_enum = MyEnum::Item(Item {
        price: 5,
        amount: 2,
        id: 42,
    });
}
</code></pre>
<h3 id="enums-of-enums"><a class="header" href="#enums-of-enums">Enums of Enums</a></h3>
<p>It is possible to define enums of enums:</p>
<pre><code class="language-sway">library;

pub enum Error {
    StateError: StateError,
    UserError: UserError,
}

pub enum StateError {
    Void: (),
    Pending: (),
    Completed: (),
}

pub enum UserError {
    InsufficientPermissions: (),
    Unauthorized: (),
}
</code></pre>
<h4 id="preferred-usage"><a class="header" href="#preferred-usage">Preferred usage</a></h4>
<p>The preferred way to use enums is to use the individual (not nested) enums directly because they are easy to follow and the lines are short:</p>
<pre><code class="language-sway">library;

use ::enum_of_enums::{StateError, UserError};

fn preferred() {
    let error1 = StateError::Void;
    let error2 = UserError::Unauthorized;
}
</code></pre>
<h4 id="inadvisable"><a class="header" href="#inadvisable">Inadvisable</a></h4>
<p>If you wish to use the nested form of enums via the <code>Error</code> enum from the example above, then you can instantiate them into variables using the following syntax:</p>
<pre><code class="language-sway">library;

use ::enum_of_enums::{Error, StateError, UserError};

fn avoid() {
    let error1 = Error::StateError(StateError::Void);
    let error2 = Error::UserError(UserError::Unauthorized);
}
</code></pre>
<p>Key points to note:</p>
<ul>
<li>You must import all of the enums you need instead of just the <code>Error</code> enum</li>
<li>The lines may get unnecessarily long (depending on the names)</li>
<li>The syntax is not the most ergonomic</li>
</ul>
<h3 id="enum-memory-layout"><a class="header" href="#enum-memory-layout">Enum Memory Layout</a></h3>
<blockquote>
<p><strong>Note</strong>
This information is not vital if you are new to the language, or programming in general.</p>
</blockquote>
<p>Enums do have some memory overhead. To know which variant is being represented, Sway stores a one-word (8-byte) tag for the enum variant. The space reserved after the tag is equivalent to the size of the <em>largest</em> enum variant. So, to calculate the size of an enum in memory, add 8 bytes to the size of the largest variant. For example, in the case of <code>Color</code> above, where the variants are all <code>()</code>, the size would be 8 bytes since the size of the largest variant is 0 bytes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods-and-associated-functions"><a class="header" href="#methods-and-associated-functions">Methods and Associated Functions</a></h1>
<!-- This section should explain methods & associated functions in Sway -->
<!-- methods_af:example:start -->
<p>Methods are similar to functions in that we declare them with the <code>fn</code> keyword and they have parameters and return a value. However, unlike functions, <em>Methods</em> are defined within the context of a struct (or enum), and either refers to that type or mutates it. The first parameter of a method is always <code>self</code>, which represents the instance of the struct the method is being called on.</p>
<p><em>Associated functions</em> are very similar to <em>methods</em>, in that they are also defined in the context of a struct or enum, but they do not actually use any of the data in the struct and as a result do not take <em>self</em> as a parameter. Associated functions could be standalone functions, but they are included in a specific type for organizational or semantic reasons.</p>
<p>To declare methods and associated functions for a struct or enum, use an <em>impl block</em>. Here, <code>impl</code> stands for implementation.</p>
<!-- methods_af:example:end -->
<pre><code class="language-sway">script;

struct Foo {
    bar: u64,
    baz: bool,
}

impl Foo {
    // this is a _method_, as it takes `self` as a parameter.
    fn is_baz_true(self) -&gt; bool {
        self.baz
    }

    // this is an _associated function_, since it does not take `self` as a parameter.
    fn new_foo(number: u64, boolean: bool) -&gt; Foo {
        Foo {
            bar: number,
            baz: boolean,
        }
    }
}

fn main() {
    let foo = Foo::new_foo(42, true);
    assert(foo.is_baz_true());
}
</code></pre>
<!-- This section should explain how to call a method -->
<!-- call_method:example:start -->
<p>To call a method, simply use dot syntax: <code>foo.iz_baz_true()</code>.</p>
<!-- call_method:example:end -->
<!-- This section should explain how methods + assoc. fns can accept `ref mut` params -->
<!-- ref_mut:example:start -->
<p>Similarly to <a href="basics/functions.html">free functions</a>, methods and associated functions may accept <code>ref mut</code> parameters.</p>
<!-- ref_mut:example:end -->
<p>For example:</p>
<pre><code class="language-sway">struct Coordinates {
    x: u64,
    y: u64,
}

impl Coordinates {
    fn move_right(ref mut self, distance: u64) {
        self.x += distance;
    }
}
</code></pre>
<p>and when called:</p>
<pre><code class="language-sway">    let mut point = Coordinates { x: 1, y: 1 };
    point.move_right(5);
    assert(point.x == 6);
    assert(point.y == 1);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<!-- This section should explain what constants are in Sway -->
<!-- constants:example:start -->
<p>Constants are similar to variables; however, there are a few differences:</p>
<ul>
<li>Constants are always evaluated at compile-time</li>
<li>Constants can be declared both inside of a <a href="basics/../index.html">function</a> and at global / <code>impl</code> scope.</li>
<li>The <code>mut</code> keyword cannot be used with constants.</li>
</ul>
<!-- constants:example:end -->
<pre><code class="language-sway">const ID: u32 = 0;
</code></pre>
<p>Constant initializer expressions can be quite complex, but they cannot use, for
instance, assembly instructions, storage access, mutable variables, loops and
<code>return</code> statements. Although, function calls, primitive types and compound data
structures are perfectly fine to use:</p>
<pre><code class="language-sway">fn bool_to_num(b: bool) -&gt; u64 {
    if b {
        1
    } else {
        0
    }
}

fn arr_wrapper(a: u64, b: u64, c: u64) -&gt; [u64; 3] {
    [a, b, c]
}

const ARR2 = arr_wrapper(bool_to_num(1) + 42, 2, 3);
</code></pre>
<h2 id="associated-constants"><a class="header" href="#associated-constants">Associated Constants</a></h2>
<!-- This section should explain what associated constants are -->
<!-- assoc_constants:example:start -->
<p>Associated constants are constants associated with a type and can be declared in an <code>impl</code> block or in a <code>trait</code> definition.</p>
<p>Associated constants declared inside a <code>trait</code> definition may omit their initializers to indicate that each implementation of the trait must specify those initializers.</p>
<p>The identifier is the name of the constant used in the path. The type is the type that the
definition has to implement.</p>
<!-- assoc_constants:example:end -->
<p>You can <em>define</em> an associated const directly in the interface surface of a trait:</p>
<pre><code class="language-sway">script;

trait ConstantId {
    const ID: u32 = 0;
}
</code></pre>
<p>Alternatively, you can also <em>declare</em> it in the trait, and implement it in the interface of the
types implementing the trait.</p>
<pre><code class="language-sway">script;

trait ConstantId {
    const ID: u32;
}

struct Struct {}

impl ConstantId for Struct {
    const ID: u32 = 1;
}

fn main() -&gt; u32 {
    Struct::ID
}
</code></pre>
<h3 id="impl-self-consts"><a class="header" href="#impl-self-consts"><code>impl self</code> consts</a></h3>
<p>Constants can also be declared inside non-trait <code>impl</code> blocks.</p>
<pre><code class="language-sway">script;

struct Point {
    x: u64,
    y: u64,
}

impl Point {
    const ZERO: Point = Point { x: 0, y: 0 };
}

fn main() -&gt; u64  {
    Point::ZERO.x
}
</code></pre>
<h2 id="configurable-constants"><a class="header" href="#configurable-constants">Configurable Constants</a></h2>
<!-- This section should explain what configurable constants are in Sway -->
<!-- config_constants:example:start -->
<p>Configurable constants are special constants that behave like regular constants in the sense that they cannot change during program execution, but they can be configured <em>after</em> the Sway program has been built. The Rust and TS SDKs allow updating the values of these constants by injecting new values for them directly in the bytecode without having to build the program again. These are useful for contract factories and behave somewhat similarly to <code>immutable</code> variables from languages like Solidity.</p>
<!-- config_constants:example:end -->
<p>Configurable constants are declared inside a <code>configurable</code> block and require a type ascription and an initializer as follows:</p>
<pre><code class="language-sway">configurable {
    U8: u8 = 8u8,
    BOOL: bool = true,
    ARRAY: [u32; 3] = [253u32, 254u32, 255u32],
    STR_4: str[4] = &quot;fuel&quot;,
    STRUCT: StructWithGeneric&lt;u8&gt; = StructWithGeneric {
        field_1: 8u8,
        field_2: 16,
    },
    ENUM: EnumWithGeneric&lt;bool&gt; = EnumWithGeneric::VariantOne(true),
}
</code></pre>
<p>At most one <code>configurable</code> block is allowed in a Sway project. Moreover, <code>configurable</code> blocks are not allowed in libraries.</p>
<p>Configurable constants can be read directly just like regular constants:</p>
<pre><code class="language-sway">    fn return_configurables() -&gt; (u8, bool, [u32; 3], str[4], StructWithGeneric&lt;u8&gt;) {
        (U8, BOOL, ARRAY, STR_4, STRUCT)
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-and-logging"><a class="header" href="#comments-and-logging">Comments and Logging</a></h1>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<!-- This section should explain how to add comments in Sway -->
<!-- comments:example:start -->
<p>Comments in Sway start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you'll need to include <code>//</code> on each line.</p>
<!-- comments:example:end -->
<pre><code class="language-sway">// hello world
</code></pre>
<pre><code class="language-sway">// let's make a couple of lines
// commented.
</code></pre>
<p>You can also place comments at the ends of lines containing code.</p>
<pre><code class="language-sway">fn main() {
    let baz = 8; // Eight is a lucky number
}
</code></pre>
<p>You can also do block comments</p>
<pre><code class="language-sway">fn main() {
    /*
    You can write on multiple lines
    like this if you want
    */
    let baz = 8;
}
</code></pre>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<!-- This section should explain logging in Sway -->
<!-- logging:example:start -->
<p>The <code>logging</code> library provides a generic <code>log</code> function that can be imported using <code>use std::logging::log</code> and used to log variables of any type. Each call to <code>log</code> appends a <code>receipt</code> to the list of receipts. There are two types of receipts that a <code>log</code> can generate: <code>Log</code> and <code>LogData</code>.</p>
<!-- logging:example:end -->
<pre><code class="language-sway">fn log_values(){
  // Generates a Log receipt
  log(42);

  // Generates a LogData receipt
  let string = &quot;sway&quot;;
  log(string);
}
</code></pre>
<h3 id="log-receipt"><a class="header" href="#log-receipt"><code>Log</code> Receipt</a></h3>
<!-- This section should explain when `Log` receipts are produced -->
<!-- log_rec:example:start -->
<p>The <code>Log</code> receipt is generated for <em>non-reference</em> types, namely <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>u64</code>.</p>
<!-- log_rec:example:end -->
<p>For example, logging an integer variable <code>x</code> that holds the value <code>42</code> using <code>log(x)</code> may generate the following receipt:</p>
<pre><code class="language-console">&quot;Log&quot;: {
  &quot;id&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;is&quot;: 10352,
  &quot;pc&quot;: 10404,
  &quot;ra&quot;: 42,
  &quot;rb&quot;: 1018205,
  &quot;rc&quot;: 0,
  &quot;rd&quot;: 0
}
</code></pre>
<p>Note that <code>ra</code> will include the value being logged. The additional registers <code>rc</code> and <code>rd</code> will be zero when using <code>log</code> while <code>rb</code> may include a non-zero value representing a unique ID for the <code>log</code> instance. The unique ID is not meaningful on its own but allows the Rust and the TS SDKs to know the type of the data being logged, by looking up the log ID in the JSON ABI file.</p>
<h3 id="logdata-receipt"><a class="header" href="#logdata-receipt"><code>LogData</code> Receipt</a></h3>
<!-- This section should explain when `LogData` receipts are produced -->
<!-- log_data_rec:example:start -->
<p><code>LogData</code> is generated for <em>reference</em> types which include all types except for <em>non_reference</em> types.</p>
<!-- log_data_rec:example:end -->
<p>For example, logging a <code>b256</code> variable <code>b</code> that holds the value <code>0x1111111111111111111111111111111111111111111111111111111111111111</code> using <code>log(b)</code> may generate the following receipt:</p>
<pre><code class="language-console">&quot;LogData&quot;: {
  &quot;data&quot;: &quot;1111111111111111111111111111111111111111111111111111111111111111&quot;,
  &quot;digest&quot;: &quot;02d449a31fbb267c8f352e9968a79e3e5fc95c1bbeaa502fd6454ebde5a4bedc&quot;,
  &quot;id&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;is&quot;: 10352,
  &quot;len&quot;: 32,
  &quot;pc&quot;: 10444,
  &quot;ptr&quot;: 10468,
  &quot;ra&quot;: 0,
  &quot;rb&quot;: 1018194
}
</code></pre>
<p>Note that <code>data</code> in the receipt above will include the value being logged as a hexadecimal. Similarly to the <code>Log</code> receipt, additional registers are written: <code>ra</code> will always be zero when using <code>log</code>, while <code>rb</code> will contain a unique ID for the <code>log</code> instance.</p>
<blockquote>
<p><strong>Note</strong>
The Rust SDK exposes <a href="https://fuellabs.github.io/fuels-rs/master/calling-contracts/logs.html#logs">APIs</a> that allow you to retrieve the logged values and display them nicely based on their types as indicated in the JSON ABI file.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<h2 id="if-expressions"><a class="header" href="#if-expressions"><code>if</code> expressions</a></h2>
<!-- This section should explain `if` expressions in Sway -->
<!-- if:example:start -->
<p>Sway supports <em>if</em>, <em>else</em>, and <em>else if</em> expressions that allow you to branch your code depending on conditions.</p>
<!-- if:example:end -->
<p>For example:</p>
<pre><code class="language-sway">fn main() {
    let number = 6;

    if number % 4 == 0 {
        // do something
    } else if number % 3 == 0 {
        // do something else
    } else {
        // do something else
    }
}
</code></pre>
<h3 id="using-if-in-a-let-statement"><a class="header" href="#using-if-in-a-let-statement">Using <code>if</code> in a <code>let</code> statement</a></h3>
<p>Like Rust, <code>if</code>s are expressions in Sway. What this means is you can use <code>if</code> expressions on the right side of a <code>let</code> statement to assign the outcome to a variable.</p>
<pre><code class="language-sway">let my_data = if some_bool &lt; 10 { foo() } else { bar() };
</code></pre>
<p>Note that all branches of the <code>if</code> expression must return a value of the same type.</p>
<h3 id="match-expressions"><a class="header" href="#match-expressions"><code>match</code> expressions</a></h3>
<!-- This section should explain `match` expressions in Sway -->
<!-- match:example:start -->
<p>Sway supports advanced pattern matching through exhaustive <code>match</code> expressions. Unlike an <code>if</code> statement, a <code>match</code> expression asserts <strong>at compile</strong> time that all possible patterns have been matched. If you don't handle all the patterns, you will get compiler error indicating that your <code>match</code> expression is non-exhaustive.</p>
<!-- match:example:end -->
<p>The basic syntax of a <code>match</code> statement is as follows:</p>
<pre><code class="language-sway">let result = match expression {
    pattern1 =&gt; code_to_execute_if_expression_matches_pattern1,
    pattern2 =&gt; code_to_execute_if_expression_matches_pattern2,
    pattern3 | pattern4 =&gt; code_to_execute_if_expression_matches_pattern3_or_pattern4
    ...
    _ =&gt; code_to_execute_if_expression_matches_no_pattern,
}
</code></pre>
<p>Some examples of how you can use a match statement:</p>
<pre><code class="language-sway">script;

// helper functions for our example
fn on_even(num: u64) {
    // do something with even numbers
}
fn on_odd(num: u64) {
    // do something with odd numbers
}

fn main(num: u64) -&gt; u64 {
    // Match as an expression
    let is_even = match num % 2 {
        0 =&gt; true,
        _ =&gt; false,
    };

    // Match as control flow
    let x = 12;
    match x {
        5 =&gt; on_odd(x),
        _ =&gt; on_even(x),
    };

    // Match an enum
    enum Weather {
        Sunny: (),
        Rainy: (),
        Cloudy: (),
        Snowy: (),
    }
    let current_weather = Weather::Sunny;
    let avg_temp = match current_weather {
        Weather::Sunny =&gt; 80,
        Weather::Rainy =&gt; 50,
        Weather::Cloudy =&gt; 60,
        Weather::Snowy =&gt; 20,
    };

    let is_sunny = match current_weather {
        Weather::Sunny =&gt; true,
        Weather::Rainy | Weather::Cloudy | Weather::Snowy =&gt; false,
    };

    // match expression used for a return
    let outside_temp = Weather::Sunny;
    match outside_temp {
        Weather::Sunny =&gt; 80,
        Weather::Rainy =&gt; 50,
        Weather::Cloudy =&gt; 60,
        Weather::Snowy =&gt; 20,
    }
}
</code></pre>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<h3 id="while"><a class="header" href="#while"><code>while</code></a></h3>
<p>Loops in Sway are currently limited to <code>while</code> loops. This is what they look like:</p>
<pre><code class="language-sway">while counter &lt; 10 {
    counter = counter + 1;
}
</code></pre>
<p>You need the <code>while</code> keyword, some condition (<code>value &lt; 10</code> in this case) which will be evaluated each iteration, and a block of code inside the curly braces (<code>{...}</code>) to execute each iteration.</p>
<h3 id="break-and-continue"><a class="header" href="#break-and-continue"><code>break</code> and <code>continue</code></a></h3>
<p><code>break</code> and <code>continue</code> keywords are available to use inside the body of a <code>while</code> loop. The purpose of the <code>break</code> statement is to break out of a loop early:</p>
<pre><code class="language-sway">fn break_example() -&gt; u64 {
    let mut counter = 1;
    let mut sum = 0;
    let num = 10;
    while true {
        if counter &gt; num {
            break;
        }
        sum += counter;
        counter += 1;
    }
    sum // 1 + 2 + .. + 10 = 55
}
</code></pre>
<p>The purpose of the <code>continue</code> statement is to skip a portion of a loop in an iteration and jump directly into the next iteration:</p>
<pre><code class="language-sway">fn continue_example() -&gt; u64 {
    let mut counter = 0;
    let mut sum = 0;
    let num = 10;
    while counter &lt; num {
        counter += 1;
        if counter % 2 == 0 {
            continue;
        }
        sum += counter;
    }
    sum // 1 + 3 + .. + 9 = 25
}
</code></pre>
<h3 id="nested-loops"><a class="header" href="#nested-loops">Nested loops</a></h3>
<p>You can also use nested <code>while</code> loops if needed:</p>
<pre><code class="language-sway">while condition_1 == true {
    // do stuff...
    while condition_2 == true {
        // do more stuff...
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-development-with-sway"><a class="header" href="#blockchain-development-with-sway">Blockchain Development with Sway</a></h1>
<p>Sway is fundamentally a blockchain language. Because of this, it has some features and requirements that you may not have seen in general-purpose programming languages.</p>
<p>These are also some concepts related to the FuelVM and Fuel ecosystem that you may utilize when writing Sway.</p>
<ul>
<li><a href="blockchain-development/./hashing_and_cryptography.html">Hashing and Cryptography</a></li>
<li><a href="blockchain-development/./storage.html">Contract Storage</a></li>
<li><a href="blockchain-development/./purity.html">Function Purity</a></li>
<li><a href="blockchain-development/./identifiers.html">Identifiers</a></li>
<li><a href="blockchain-development/./native_assets.html">Native Assets</a></li>
<li><a href="blockchain-development/./access_control.html">Access Control</a></li>
<li><a href="blockchain-development/./calling_contracts.html">Calling Contracts</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-and-cryptography"><a class="header" href="#hashing-and-cryptography">Hashing and Cryptography</a></h1>
<p>The Sway standard library provides easy access to a selection of cryptographic hash functions (<code>sha256</code> and EVM-compatible <code>keccak256</code>), and EVM-compatible <code>secp256k1</code>-based signature recovery operations.</p>
<h2 id="hashing"><a class="header" href="#hashing">Hashing</a></h2>
<pre><code class="language-sway">script;

use std::hash::{keccak256, sha256};

const VALUE_A = 0x9280359a3b96819889d30614068715d634ad0cf9bba70c0f430a8c201138f79f;

enum Location {
    Earth: (),
    Mars: (),
}

struct Person {
    name: str[4],
    age: u64,
    alive: bool,
    location: Location,
    stats: Stats,
    some_tuple: (bool, u64),
    some_array: [u64; 2],
    some_b256: b256,
}

struct Stats {
    strength: u64,
    agility: u64,
}

fn main() {
    let zero = b256::min();
    // Use the generic sha256 to hash some integers
    let sha_hashed_u8 = sha256(u8::max());
    let sha_hashed_u16 = sha256(u16::max());
    let sha_hashed_u32 = sha256(u32::max());
    let sha_hashed_u64 = sha256(u64::max());

    // Or hash a b256
    let sha_hashed_b256 = sha256(VALUE_A);

    // You can hash booleans too
    let sha_hashed_bool = sha256(true);

    // Strings are not a problem either
    let sha_hashed_str = sha256(&quot;Fastest Modular Execution Layer!&quot;);

    // Tuples of any size work too
    let sha_hashed_tuple = sha256((true, 7));

    // As do arrays
    let sha_hashed_array = sha256([4, 5, 6]);

    // Enums work too
    let sha_hashed_enum = sha256(Location::Earth);

    // Complex structs are not a problem
    let sha_hashed_struct = sha256(Person {
        name: &quot;John&quot;,
        age: 9000,
        alive: true,
        location: Location::Mars,
        stats: Stats {
            strength: 10,
            agility: 9,
        },
        some_tuple: (true, 8),
        some_array: [17, 76],
        some_b256: zero,
    });

    log(sha_hashed_u8);
    log(sha_hashed_u16);
    log(sha_hashed_u32);
    log(sha_hashed_u64);
    log(sha_hashed_b256);
    log(sha_hashed_bool);
    log(sha_hashed_str);
    log(sha_hashed_tuple);
    log(sha_hashed_array);
    log(sha_hashed_enum);
    log(sha_hashed_struct);

    // Use the generic keccak256 to hash some integers
    let keccak_hashed_u8 = keccak256(u8::max());
    let keccak_hashed_u16 = keccak256(u16::max());
    let keccak_hashed_u32 = keccak256(u32::max());
    let keccak_hashed_u64 = keccak256(u64::max());

    // Or hash a b256
    let keccak_hashed_b256 = keccak256(VALUE_A);

    // You can hash booleans too
    let keccak_hashed_bool = keccak256(true);

    // Strings are not a problem either
    let keccak_hashed_str = keccak256(&quot;Fastest Modular Execution Layer!&quot;);

    // Tuples of any size work too
    let keccak_hashed_tuple = keccak256((true, 7));

    // As do arrays
    let keccak_hashed_array = keccak256([4, 5, 6]);

    // Enums work too
    let keccak_hashed_enum = keccak256(Location::Earth);

    // Complex structs are not a problem
    let keccak_hashed_struct = keccak256(Person {
        name: &quot;John&quot;,
        age: 9000,
        alive: true,
        location: Location::Mars,
        stats: Stats {
            strength: 10,
            agility: 9,
        },
        some_tuple: (true, 8),
        some_array: [17, 76],
        some_b256: zero,
    });

    log(keccak_hashed_u8);
    log(keccak_hashed_u16);
    log(keccak_hashed_u32);
    log(keccak_hashed_u64);
    log(keccak_hashed_b256);
    log(keccak_hashed_bool);
    log(keccak_hashed_str);
    log(keccak_hashed_tuple);
    log(keccak_hashed_array);
    log(keccak_hashed_enum);
    log(keccak_hashed_struct);
}
</code></pre>
<h2 id="signature-recovery"><a class="header" href="#signature-recovery">Signature Recovery</a></h2>
<pre><code class="language-sway">script;

use std::{b512::B512, ecr::{ec_recover, ec_recover_address, EcRecoverError}};

const MSG_HASH = 0xee45573606c96c98ba970ff7cf9511f1b8b25e6bcd52ced30b89df1e4a9c4323;

fn main() {
    let hi = 0xbd0c9b8792876713afa8bff383eebf31c43437823ed761cc3600d0016de5110c;
    let lo = 0x44ac566bd156b4fc71a4a4cb2655d3dd360c695edb17dc3b64d611e122fea23d;
    let signature: B512 = B512::from((hi, lo));

    // A recovered public key pair.
    let public_key = ec_recover(signature, MSG_HASH);

    // A recovered Fuel address.
    let result_address: Result&lt;Address, EcRecoverError&gt; = ec_recover_address(signature, MSG_HASH);
    if let Ok(address) = result_address {
        log(address.value);
    } else {
        revert(0);
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Recovery of EVM addresses is also supported via <code>std::vm::evm</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<!-- This section should explain storage in Sway -->
<!-- storage:example:start -->
<p>When developing a <a href="blockchain-development/../sway-program-types/smart_contracts.html">smart contract</a>, you will typically need some sort of persistent storage. In this case, persistent storage, often just called <em>storage</em> in this context, is a place where you can store values that are persisted inside the contract itself. This is in contrast to a regular value in <em>memory</em>, which disappears after the contract exits.</p>
<p>Put in conventional programming terms, contract storage is like saving data to a hard drive. That data is saved even after the program which saved it exits. That data is persistent. Using memory is like declaring a variable in a program: it exists for the duration of the program and is non-persistent.</p>
<p>Some basic use cases of storage include declaring an owner address for a contract and saving balances in a wallet.</p>
<!-- storage:example:end -->
<h2 id="storage-accesses-via-the-storage-keyword"><a class="header" href="#storage-accesses-via-the-storage-keyword">Storage Accesses Via the <code>storage</code> Keyword</a></h2>
<p>Declaring variables in storage requires a <code>storage</code> declaration that contains a list of all your variables, their types, and their initial values as follows:</p>
<pre><code class="language-sway">struct Type1 {
    x: u64,
    y: u64,
}

struct Type2 {
    w: b256,
    z: bool,
}

storage {
    var1: Type1 = Type1 { x: 0, y: 0 },
    var2: Type2 = Type2 {
        w: 0x0000000000000000000000000000000000000000000000000000000000000000,
        z: false,
    },
}

</code></pre>
<p>To write into a storage variable, you need to use the <code>storage</code> keyword as follows:</p>
<pre><code class="language-sway">    #[storage(write)]
    fn store_something() {
        storage.var1.x.write(42);
        storage.var1.y.write(77);
        storage.var2.w.write(0x1111111111111111111111111111111111111111111111111111111111111111);
        storage.var2.z.write(true);
    }
</code></pre>
<p>To read a storage variable, you also need to use the <code>storage</code> keyword as follows:</p>
<pre><code class="language-sway">    #[storage(read)]
    fn get_something() -&gt; (u64, u64, b256, bool) {
        (
            storage.var1.x.try_read().unwrap_or(0),
            storage.var1.y.try_read().unwrap_or(0),
            storage.var2.w.try_read().unwrap_or(0x0000000000000000000000000000000000000000000000000000000000000000),
            storage.var2.z.try_read().unwrap_or(false),
        )
    }
</code></pre>
<h2 id="storage-maps"><a class="header" href="#storage-maps">Storage Maps</a></h2>
<p>Generic storage maps are available in the standard library as <code>StorageMap&lt;K, V&gt;</code> which have to be defined inside a <code>storage</code> block and allow you to call <code>insert()</code> and <code>get()</code> to insert values at specific keys and get those values respectively. Refer to <a href="blockchain-development/../common-collections/storage_map.html">Storage Maps</a> for more information about <code>StorageMap&lt;K, V&gt;</code>.</p>
<h2 id="manual-storage-management"><a class="header" href="#manual-storage-management">Manual Storage Management</a></h2>
<p>It is possible to leverage FuelVM storage operations directly using the <code>std::storage::storage_api::write</code> and <code>std::storage::storage_api::read</code> functions provided in the standard library. With this approach you will have to manually assign the internal key used for storage. An example is as follows:</p>
<pre><code class="language-sway">contract;

use std::storage::storage_api::{read, write};

abi StorageExample {
    #[storage(write)]
    fn store_something(amount: u64);

    #[storage(read)]
    fn get_something() -&gt; u64;
}

const STORAGE_KEY: b256 = 0x0000000000000000000000000000000000000000000000000000000000000000;

impl StorageExample for Contract {
    #[storage(write)]
    fn store_something(amount: u64) {
        write(STORAGE_KEY, 0, amount);
    }

    #[storage(read)]
    fn get_something() -&gt; u64 {
        let value: Option&lt;u64&gt; = read::&lt;u64&gt;(STORAGE_KEY, 0);
        value.unwrap_or(0)
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Though these functions can be used for any data type, they should mostly be used for arrays because arrays are not yet supported in <code>storage</code> blocks. Note, however, that <em>all</em> data types can be used as types for keys and/or values in <code>StorageMap&lt;K, V&gt;</code> without any restrictions.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="purity"><a class="header" href="#purity">Purity</a></h1>
<!-- This section should explain pure functions in Sway -->
<!-- pure:example:start -->
<p>A function is <em>pure</em> if it does not access any <a href="blockchain-development/./storage.html">persistent storage</a>. Conversely, the function is <em>impure</em> if it does access any storage. Naturally, as storage is only available in smart contracts, impure functions cannot be used in predicates, scripts, or libraries. A pure function cannot call an impure function.</p>
<p>In Sway, functions are pure by default but can be opted into impurity via the <code>storage</code> function attribute. The <code>storage</code> attribute may take <code>read</code> and/or <code>write</code> arguments indicating which type of access the function requires.</p>
<!-- pure:example:end -->
<pre><code class="language-sway">#[storage(read)]
fn get_amount() -&gt; u64 {
    ...
}

#[storage(read, write)]
fn increment_amount(increment: u64) -&gt; u64 {
    ...
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: the <code>#[storage(write)]</code> attribute also permits a function to read from storage. This is due to the fact that partially writing a storage slot requires first reading the slot.</p>
</blockquote>
<!-- This section should explain impure functions in Sway -->
<!-- impure:example:start -->
<p>Impure functions which call other impure functions must have at least the same storage privileges or a superset of those for the function called. For example, to call a function with write access a caller must also have write access, or both read and write access. To call a function with read and write access the caller must also have both privileges.</p>
<!-- impure:example:end -->
<p>The <code>storage</code> attribute may also be applied to <a href="blockchain-development/../basics/methods_and_associated_functions.html">methods and associated functions</a>, <a href="blockchain-development/../advanced/traits.html">trait</a> and <a href="blockchain-development/../sway-program-types/smart_contracts.html#the-abi-declaration">ABI</a> declarations.</p>
<!-- This section should explain the benefits of using pure functions in Sway -->
<!-- pure_benefits:example:start -->
<p>A pure function gives you some guarantees: you will not incur excessive storage gas costs, the compiler can apply additional optimizations, and they are generally easy to reason about and audit.</p>
<!-- pure_benefits:example:end -->
<p><a href="https://docs.soliditylang.org/en/v0.8.10/contracts.html#pure-functions">A similar concept exists in Solidity</a>. Note that Solidity refers to contract storage as <em>contract state</em>, and in the Sway/Fuel ecosystem, these two terms are largely interchangeable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p>Addresses in Sway are similar to EVM addresses. The two major differences are:</p>
<ol>
<li>Sway addresses are 32 bytes long (instead of 20)</li>
<li>Sway addresses are computed with the SHA-256 hash of the public key instead of the keccak-256 hash.</li>
</ol>
<p>Contracts, on the other hand, are uniquely identified with a contract ID rather than an address. A contract's ID is also 32 bytes long and is calculated <a href="https://fuellabs.github.io/fuel-specs/master/protocol/id/contract">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-support-for-multiple-asset-types"><a class="header" href="#native-support-for-multiple-asset-types">Native Support for Multiple Asset Types</a></h1>
<!-- This section should explain native assets in Sway -->
<!-- native_assets:example:start -->
<p>The FuelVM has built-in support for working with multiple assets.</p>
<p>What does this mean in practice?</p>
<p>As in the EVM, sending ETH to an address or contract is an operation built into the FuelVM, meaning it doesn't rely on the existence of some token smart contract to update balances to track ownership.</p>
<p>However, unlike the EVM, the process for sending <em>any</em> native asset is the same. This means that while you would still need a smart contract to handle the minting and burning of fungible tokens, the sending and receiving of these tokens can be done independently of the token contract.</p>
<!-- native_assets:example:end -->
<h2 id="liquidity-pool-example"><a class="header" href="#liquidity-pool-example">Liquidity Pool Example</a></h2>
<p>All contracts in Fuel can mint and burn their own native token. Contracts can also receive and transfer any native asset including their own. Internal balances of all native assets pushed through calls or minted by the contract are tracked by the FuelVM and can be queried at any point using the balance_of function from the <code>std</code> library. Therefore, there is no need for any manual accounting of the contract's balances using persistent storage.</p>
<p>The <code>std</code> library provides handy methods for accessing Fuel's native assset operations.</p>
<p>In this example, we show a basic liquidity pool contract minting its own native asset LP token.</p>
<pre><code class="language-sway">contract;

use std::{
    call_frames::{
        contract_id,
        msg_asset_id,
    },
    context::msg_amount,
    token::{
        mint_to_address,
        transfer_to_address,
    },
};

abi LiquidityPool {
    fn deposit(recipient: Address);
    fn withdraw(recipient: Address);
}

const BASE_TOKEN = ContractId::from(0x9ae5b658754e096e4d681c548daf46354495a437cc61492599e33fc64dcdc30c);

impl LiquidityPool for Contract {
    fn deposit(recipient: Address) {
        assert(msg_asset_id() == BASE_TOKEN);
        assert(msg_amount() &gt; 0);

        // Mint two times the amount.
        let amount_to_mint = msg_amount() * 2;

        // Mint some LP token based upon the amount of the base token.
        mint_to_address(amount_to_mint, recipient);
    }

    fn withdraw(recipient: Address) {
        assert(msg_asset_id() == contract_id());
        assert(msg_amount() &gt; 0);

        // Amount to withdraw.
        let amount_to_transfer = msg_amount() / 2;

        // Transfer base token to recipient.
        transfer_to_address(amount_to_transfer, BASE_TOKEN, recipient);
    }
}
</code></pre>
<h2 id="native-token-example"><a class="header" href="#native-token-example">Native Token Example</a></h2>
<p>In this example, we show a native token contract with more minting, burning and transferring capabilities.</p>
<pre><code class="language-sway">contract;

use std::{context::*, token::*};

abi NativeAssetToken {
    fn mint_coins(mint_amount: u64);
    fn burn_coins(burn_amount: u64);
    fn force_transfer_coins(coins: u64, asset_id: ContractId, target: ContractId);
    fn transfer_coins_to_output(coins: u64, asset_id: ContractId, recipient: Address);
    fn deposit();
    fn get_balance(target: ContractId, asset_id: ContractId) -&gt; u64;
    fn mint_and_send_to_contract(amount: u64, destination: ContractId);
    fn mint_and_send_to_address(amount: u64, recipient: Address);
}

impl NativeAssetToken for Contract {
    /// Mint an amount of this contracts native asset to the contracts balance.
    fn mint_coins(mint_amount: u64) {
        mint(mint_amount);
    }

    /// Burn an amount of this contracts native asset.
    fn burn_coins(burn_amount: u64) {
        burn(burn_amount);
    }

    /// Transfer coins to a target contract.
    fn force_transfer_coins(coins: u64, asset_id: ContractId, target: ContractId) {
        force_transfer_to_contract(coins, asset_id, target);
    }

    /// Transfer coins to a transaction output to be spent later.
    fn transfer_coins_to_output(coins: u64, asset_id: ContractId, recipient: Address) {
        transfer_to_address(coins, asset_id, recipient);
    }

    /// Get the internal balance of a specific coin at a specific contract.
    fn get_balance(target: ContractId, asset_id: ContractId) -&gt; u64 {
        balance_of(target, asset_id)
    }

    /// Deposit tokens back into the contract.
    fn deposit() {
        assert(msg_amount() &gt; 0);
    }

    /// Mint and send this contracts native token to a destination contract.
    fn mint_and_send_to_contract(amount: u64, destination: ContractId) {
        mint_to_contract(amount, destination);
    }

    /// Mind and send this contracts native token to a destination address.
    fn mint_and_send_to_address(amount: u64, recipient: Address) {
        mint_to_address(amount, recipient);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-control"><a class="header" href="#access-control">Access Control</a></h1>
<!-- This section should explain access control in Sway -->
<!-- access_control:example:start -->
<p>Smart contracts require the ability to restrict access to and identify certain users or contracts. Unlike account-based blockchains, transactions in UTXO-based blockchains (i.e. Fuel) do not necessarily have a unique transaction sender. Additional logic is needed to handle this difference, and is provided by the standard library.</p>
<!-- access_control:example:end -->
<h2 id="msg_sender"><a class="header" href="#msg_sender"><code>msg_sender</code></a></h2>
<!-- This section should explain what the `msg_sender` method is -->
<!-- msg_sender:example:start -->
<p>To deliver an experience akin to the EVM's access control, the <code>std</code> library provides a <code>msg_sender</code> function, which identifies a unique caller based upon the call and/or transaction input data.</p>
<!-- msg_sender:example:end -->
<pre><code class="language-sway">contract;

abi MyOwnedContract {
    fn receive(field_1: u64) -&gt; bool;
}

const OWNER = Address::from(0x9ae5b658754e096e4d681c548daf46354495a437cc61492599e33fc64dcdc30c);

impl MyOwnedContract for Contract {
    fn receive(field_1: u64) -&gt; bool {
        let sender = msg_sender().unwrap();
        if let Identity::Address(addr) = sender {
            assert(addr == OWNER);
        } else {
            revert(0);
        }

        true
    }
}
</code></pre>
<!-- This section should explain how the `msg_sender` method works -->
<!-- msg_sender_details:example:start -->
<p>The <code>msg_sender</code> function works as follows:</p>
<ul>
<li>If the caller is a contract, then <code>Ok(Sender)</code> is returned with the <code>ContractId</code> sender variant.</li>
<li>If the caller is external (i.e. from a script), then all coin input owners in the transaction are checked. If all owners are the same, then <code>Ok(Sender)</code> is returned with the <code>Address</code> sender variant.</li>
<li>If the caller is external and coin input owners are different, then the caller cannot be determined and a <code>Err(AuthError)</code> is returned.</li>
</ul>
<!-- msg_sender_details:example:end -->
<h2 id="contract-ownership"><a class="header" href="#contract-ownership">Contract Ownership</a></h2>
<p>Many contracts require some form of ownership for access control. To accomplish this, it is recommended that a storage variable of type <code>Option&lt;Identity&gt;</code> is used to keep track of the owner. This allows setting and revoking ownership using the variants <code>Some(..)</code> and <code>None</code> respectively. This is better, safer, and more readable than using the <code>Identity</code> type directly where revoking ownership has to be done using some magic value such as <code>std::constants::ZERO_B256</code> or otherwise.</p>
<p>The following is an example of how to properly set ownership of a contract:</p>
<pre><code class="language-sway">    #[storage(write)]
    fn set_owner(identity: Identity) {
        storage.owner.write(Some(identity));
    }
</code></pre>
<p>The following is an example of how to properly revoke ownership of a contract:</p>
<pre><code class="language-sway">    #[storage(write)]
    fn revoke_ownership() {
        storage.owner.write(None);
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-contracts"><a class="header" href="#calling-contracts">Calling Contracts</a></h1>
<p>Smart contracts can be <em>called</em> by other contracts or scripts. In the FuelVM, this is done primarily with the <a href="https://fuellabs.github.io/fuel-specs/master/vm/instruction_set#call-call-contract"><code>call</code></a> instruction.</p>
<p>Sway provides a nice way to manage callable interfaces with its <code>abi</code> system. The Fuel ABI specification can be found <a href="https://fuellabs.github.io/fuel-specs/master/protocol/abi">here</a>.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>Here is an example of a contract calling another contract in Sway. A script can call a contract in the same way.</p>
<pre><code class="language-sway">// ./contract_a.sw
contract;

abi ContractA {
    fn receive(field_1: bool, field_2: u64) -&gt; u64;
}

impl ContractA for Contract {
    fn receive(field_1: bool, field_2: u64) -&gt; u64 {
        assert(field_1 == true);
        assert(field_2 &gt; 0);
        return_45()
    }
}

fn return_45() -&gt; u64 {
  45
}
</code></pre>
<pre><code class="language-sway">// ./contract_b.sw
contract;

use contract_a::ContractA;

abi ContractB {
    fn make_call();
}

const contract_id = 0x79fa8779bed2f36c3581d01c79df8da45eee09fac1fd76a5a656e16326317ef0;

impl ContractB for Contract {
    fn make_call() {
      let x = abi(ContractA, contract_id);
      let return_value = x.receive(true, 3); // will be 45
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: The ABI is for external calls only therefore you cannot define a method in the ABI and call it in the same contract. If you want to define a function for a contract, but keep it private so that only your contract can call it, you can define it outside of the <code>impl</code> and call it inside the contract, similar to the <code>return_45()</code> function above.</p>
</blockquote>
<h2 id="advanced-calls"><a class="header" href="#advanced-calls">Advanced Calls</a></h2>
<p>All calls forward a gas stipend, and may additionally forward one native asset with the call.</p>
<p>Here is an example of how to specify the amount of gas (<code>gas</code>), the asset ID of the native asset (<code>asset_id</code>), and the amount of the native asset (<code>coins</code>) to forward:</p>
<pre><code class="language-sway">script;

abi MyContract {
    fn foo(field_1: bool, field_2: u64);
}

fn main() {
    let x = abi(MyContract, 0x79fa8779bed2f36c3581d01c79df8da45eee09fac1fd76a5a656e16326317ef0);
    let asset_id = 0x7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777;
    x.foo {
        gas: 5000, asset_id: asset_id, coins: 5000
    }
    (true, 3);
}
</code></pre>
<h2 id="handling-re-entrancy"><a class="header" href="#handling-re-entrancy">Handling Re-entrancy</a></h2>
<p>A common attack vector for smart contracts is <a href="https://docs.soliditylang.org/en/v0.8.4/security-considerations.html#re-entrancy">re-entrancy</a>. Similar to the EVM, the FuelVM allows for re-entrancy.</p>
<p>A <em>stateless</em> re-entrancy guard is included in the <a href="https://github.com/FuelLabs/sway-libs">sway-libs</a> library. The guard will panic (revert) at run time if re-entrancy is detected.</p>
<pre><code class="language-sway">contract;

use reentrancy::reentrancy_guard;

abi MyContract {
    fn some_method();
}

impl ContractB for Contract {
    fn some_method() {
        reentrancy_guard();
        // do something
    }
}
</code></pre>
<h3 id="cei-pattern-violation-static-analysis"><a class="header" href="#cei-pattern-violation-static-analysis">CEI pattern violation static analysis</a></h3>
<p>Another way of avoiding re-entrancy-related attacks is to follow the so-called
<em>CEI</em> pattern. CEI stands for &quot;Checks, Effects, Interactions&quot;, meaning that the
contract code should first perform safety checks, also known as
&quot;pre-conditions&quot;, then perform effects, i.e. modify or read the contract storage
and execute external contract calls (interaction) only at the very end of the
function/method.</p>
<p>Please see this <a href="https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html">blog post</a>
for more detail on some vulnerabilities in case of storage modification after
interaction and this <a href="https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem">blog post</a> for
more information on storage reads after interaction.</p>
<p>The Sway compiler implements a check that the CEI pattern is not violated in the
user contract and issues warnings if that's the case.</p>
<p>For example, in the following contract the CEI pattern is violated, because an
external contract call is executed before a storage write.</p>
<pre><code class="language-sway">contract;

mod other_contract;

use other_contract::*;

abi MyContract {
    #[storage(read, write)]
    fn withdraw(external_contract_id: ContractId);
}

storage {
    balances: StorageMap&lt;Identity, u64&gt; = StorageMap {},
}

impl MyContract for Contract {
    #[storage(read, write)]
    fn withdraw(external_contract_id: ContractId) {
        let sender = msg_sender().unwrap();
        let bal = storage.balances.get(sender).try_read().unwrap_or(0);

        assert(bal &gt; 0);

        // External call
        let caller = abi(OtherContract, external_contract_id.into());
        caller.external_call { coins: bal }();

        // Storage update _after_ external call
        storage.balances.insert(sender, 0);
    }
}
</code></pre>
<p>Here, <code>other_contract</code> is defined as follows:</p>
<pre><code class="language-sway">library;

abi OtherContract {
    #[payable]
    fn external_call();
}
</code></pre>
<p>The CEI pattern analyzer issues a warning as follows, pointing to the
interaction before a storage modification:</p>
<pre><code class="language-sh">warning
  --&gt; /path/to/contract/main.sw:28:9
   |
26 |
27 |           let caller = abi(OtherContract, external_contract_id.into());
28 |           caller.external_call { coins: bal }();
   |  _________-
29 | |
30 | |         // Storage update _after_ external call
31 | |         storage.balances.insert(sender, 0);
   | |__________________________________________- Storage write after external contract interaction in function or method &quot;withdraw&quot;. Consider making all storage writes before calling another contract
32 |       }
33 |   }
   |
____
</code></pre>
<p>In case there is a storage read after an interaction, the CEI analyzer will issue a similar warning.</p>
<p>In addition to storage reads and writes after an interaction, the CEI analyzer reports analogous warnings about:</p>
<ul>
<li>balance tree updates, i.e. balance tree reads with subsequent writes, which may be produced by the <code>tr</code> and <code>tro</code> asm instructions or library functions using them under the hood;</li>
<li>balance trees reads with <code>bal</code> instruction;</li>
<li>changes to the output messages that can be produced by the <code>__smo</code> intrinsic function or the <code>smo</code> asm instruction.</li>
</ul>
<h2 id="differences-from-the-evm"><a class="header" href="#differences-from-the-evm">Differences from the EVM</a></h2>
<p>While the Fuel contract calling paradigm is similar to the EVM's (using an ABI, forwarding gas and data), it differs in <em>two</em> key ways:</p>
<ol>
<li>
<p><a href="blockchain-development/./native_assets.html"><strong>Native assets</strong></a>: FuelVM calls can forward any native asset not just base asset.</p>
</li>
<li>
<p><strong>No data serialization</strong>: Contract calls in the FuelVM do not need to serialize data to pass it between contracts; instead they simply pass a pointer to the data. This is because the FuelVM has a shared global memory which all call frames can read from.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-concepts"><a class="header" href="#advanced-concepts">Advanced Concepts</a></h1>
<p>Advanced concepts.</p>
<ul>
<li><a href="advanced/./advanced_types.html">Advanced Types</a></li>
<li><a href="advanced/./generic_types.html">Generic Types</a></li>
<li><a href="advanced/./traits.html">Traits</a></li>
<li><a href="advanced/./generics_and_trait_constraints.html">Generics and Trait Constraints</a></li>
<li><a href="advanced/./assembly.html">Assembly</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-types"><a class="header" href="#advanced-types">Advanced Types</a></h1>
<h2 id="creating-type-synonyms-with-type-aliases"><a class="header" href="#creating-type-synonyms-with-type-aliases">Creating Type Synonyms with Type Aliases</a></h2>
<p>Sway provides the ability to declare a type alias to give an existing type another name. For this we use the <code>type</code> keyword. For example, we can create the alias <code>Kilometers</code> to <code>u64</code> like so:</p>
<pre><code class="language-sway">type Kilometers = u64;
</code></pre>
<p>Now, the alias <code>Kilometers</code> is a <em>synonym</em> for <code>u64</code>. Note that <code>Kilometers</code> is <strong>not</strong> a separate new type. Values that have the type <code>Kilometers</code> will be treated the same as values of type <code>u64</code>:</p>
<pre><code class="language-sway">    let x: u64 = 5;
    let y: Kilometers = 5;
    assert(x + y == 10);
</code></pre>
<p>Because <code>Kilometers</code> and <code>u64</code> are the same type, we can add values of both types and we can pass <code>Kilometers</code> values to functions that take <code>u64</code> parameters. However, using this method, we don’t get the type checking benefits that we get from introducing a <em>separate</em> new type called <code>Kilometers</code>. In other words, if we mix up <code>Kilometers</code> and <code>i32</code> values somewhere, the compiler will not give us an error.</p>
<p>The main use case for type synonyms is to reduce repetition. For example, we might have a lengthy array type like this:</p>
<pre><code class="language-sway">[MyStruct&lt;u64, b256&gt;; 5]
</code></pre>
<p>Writing this lengthy type in function signatures and as type annotations all over the code can be tiresome and error prone. Imagine having a project full of code like this:</p>
<pre><code class="language-sway">fn foo_long(array: [MyStruct&lt;u64, b256&gt;; 5]) -&gt; [MyStruct&lt;u64, b256&gt;; 5] {
    array
}
</code></pre>
<p>A type alias makes this code more manageable by reducing the repetition. Below, we’ve introduced an alias named <code>MyArray</code> for the verbose type and can replace all uses of the type with the shorter alias <code>MyArray</code>:</p>
<pre><code class="language-sway">type MyArray = [MyStruct&lt;u64, b256&gt;; 5];

fn foo_shorter(array: MyArray) -&gt; MyArray {
    array
}
</code></pre>
<p>This code is much easier to read and write! Choosing a meaningful name for a type alias can help communicate your intent as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-types"><a class="header" href="#generic-types">Generic Types</a></h1>
<h2 id="basics"><a class="header" href="#basics">Basics</a></h2>
<p>In Sway, generic types follow a very similar pattern to those in Rust. Let's look at some example syntax,
starting with a generic function:</p>
<pre><code class="language-sway">fn noop&lt;T&gt;(argument: T) -&gt; T {
    argument
}
</code></pre>
<p>Here, the <code>noop()</code> function trivially returns exactly what was given to it. <code>T</code> is a <em>type parameter</em>, and it says
that this function exists for all types T. More formally, this function could be typed as:</p>
<pre><code class="language-math">noop :: ∀T. T -&gt; T
</code></pre>
<p>Generic types are a way to refer to types <em>in general</em>, meaning without specifying a single type. Our <code>noop</code> function
would work with any type in the language, so we don't need to specify <code>noop(argument: u8) -&gt; u8</code>, <code>noop(argument: u16) -&gt; u16</code>, etc.</p>
<h2 id="code-generation"><a class="header" href="#code-generation">Code Generation</a></h2>
<p>One question that arises when dealing with generic types is: how does the assembly handle this? There are a few approaches to handling
generic types at the lowest level. Sway uses a technique called <a href="https://en.wikipedia.org/wiki/Monomorphization">monomorphization</a>. This
means that the generic function is compiled to a non-generic version for every type it is called on. In this way, generic functions are
purely shorthand for the sake of ergonomics.</p>
<h2 id="trait-constraints"><a class="header" href="#trait-constraints">Trait Constraints</a></h2>
<blockquote>
<p><strong>Note</strong> Trait constraints <a href="https://github.com/FuelLabs/sway/issues/970">have not yet been implemented</a></p>
</blockquote>
<p>Important background to know before diving into trait constraints is that the <code>where</code> clause can be used to specify the required traits for the generic argument. So, when writing something like a <code>HashMap</code> you may
want to specify that the generic argument implements a <code>Hash</code> trait.</p>
<pre><code class="language-sway">fn get_hashmap_key&lt;T&gt;(Key : T) -&gt; b256
    where T: Hash
{
    // Code within here can then call methods associated with the Hash trait on Key
}
</code></pre>
<p>Of course, our <code>noop()</code> function is not useful. Often, a programmer will want to declare functions over types which satisfy certain traits.
For example, let's try to implement the successor function, <code>successor()</code>, for all numeric types.</p>
<pre><code class="language-sway">fn successor&lt;T&gt;(argument: T)
    where T: Add
{
    argument + 1
}
</code></pre>
<p>Run <code>forc build</code>, and you will get:</p>
<pre><code class="language-console">.. |
 9 |   where T: Add
10 |   {
11 |       argument + 1                                        
   |                  ^ Mismatched types: expected type &quot;T&quot; but saw type &quot;u64&quot;
12 |   }
13 |
</code></pre>
<p>This is because we don't know for a fact that <code>1</code>, which in this case defaulted to <code>1u64</code>, actually can be added to <code>T</code>. What if <code>T</code> is <code>f64</code>? Or <code>b256</code>? What does it mean to add <code>1u64</code> in these cases?</p>
<p>We can solve this problem with another trait constraint. We can only find the successor of some value of type <code>T</code> if that type <code>T</code> defines some incrementor. Let's make a trait:</p>
<pre><code class="language-sway">trait Incrementable {
    /// Returns the value to add when calculating the successor of a value.
    fn incrementor() -&gt; Self;
}
</code></pre>
<p>Now, we can modify our <code>successor()</code> function:</p>
<pre><code class="language-sway">fn successor&lt;T&gt;(argument: T)
    where T: Add,
          T: Incrementable
{
    argument + T::incrementor()
}
</code></pre>
<h2 id="generic-structs-and-enums"><a class="header" href="#generic-structs-and-enums">Generic Structs and Enums</a></h2>
<p>Just like functions, structs and enums can be generic. Let's take a look at the standard library version of <code>Option&lt;T&gt;</code>:</p>
<pre><code class="language-sway">enum Option&lt;T&gt; {
    Some: T,
    None: (),
}
</code></pre>
<p>Just like an unconstrained generic function, this type exists for all (∀) types <code>T</code>. <code>Result&lt;T, E&gt;</code> is another example:</p>
<pre><code class="language-sway">enum Result&lt;T, E&gt; {
    Ok: T,
    Err: E,
}
</code></pre>
<p>Both generic enums and generic structs can be trait constrained, as well. Consider this struct:</p>
<pre><code class="language-sway">struct Foo&lt;T&gt;
    where T: Add
{
    field_one: T,
}
</code></pre>
<h2 id="type-arguments"><a class="header" href="#type-arguments">Type Arguments</a></h2>
<p>Similar to Rust, Sway has what is colloquially known as the <a href="https://github.com/rust-lang/rust/blob/e98309298d927307c5184f4869604bd068d26183/src/test/ui/parser/bastion-of-the-turbofish.rs">turbofish</a>. The turbofish looks like this: <code>::&lt;&gt;</code> (see the little fish with bubbles behind it?). The turbofish is used to annotate types in a generic context. Say you have the following function:</p>
<pre><code class="language-sway">fn foo&lt;T, E&gt;(t: T) -&gt; Result&lt;T, E&gt; {
    Ok(t)
}
</code></pre>
<p>In this code example, which is admittedly asinine, you can't possibly know what type <code>E</code> is. You'd need to provide the type manually, with a turbofish:</p>
<pre><code class="language-sway">fn foo&lt;T, E&gt;(t: T) -&gt; Result&lt;T, E&gt; {
    Ok::&lt;T, MyErrorType&gt;(t)
}
</code></pre>
<p>It is also common to see the turbofish used on the function itself:</p>
<pre><code class="language-sway">fn main() {
    foo::&lt;Bar, Baz&gt;()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<h2 id="declaring-a-trait"><a class="header" href="#declaring-a-trait">Declaring a Trait</a></h2>
<p>A <em>trait</em> opts a type into a certain type of behavior or functionality that can be shared among types. This allows for easy reuse of code and generic programming. If you have ever used a typeclass in Haskell, a trait in Rust, or even an interface in Java, these are similar concepts.</p>
<p>Let's take a look at some code:</p>
<pre><code class="language-sway">trait Compare {
    fn equals(self, b: Self) -&gt; bool;
} {
    fn not_equals(self, b: Self) -&gt; bool {
        !self.equals(b)
    }
}
</code></pre>
<p>We have just declared a trait called <code>Compare</code>. After the name of the trait, there are two <em>blocks</em> of code (a <em>block</em> is code enclosed in <code>{</code> curly brackets <code>}</code>). The first block is the <em>interface surface</em>. The second block is the <em>methods</em> provided by the trait. If a type can provide the methods in the interface surface, then it gets access to the methods in the trait for free! What the above trait is saying is: if you can determine if two values are equal, then for free, you can determine that they are not equal. Note that trait methods have access to the methods defined in the interface surface.</p>
<h2 id="implementing-a-trait"><a class="header" href="#implementing-a-trait">Implementing a Trait</a></h2>
<p>Ok, so I know that numbers can be equal. I want to implement my <code>Compare</code> trait for <code>u64</code>. Let's take a look at how that is done:</p>
<pre><code class="language-sway">impl Compare for u64 {
    fn equals(self, b: Self) -&gt; bool {
        self == b
    }
}
</code></pre>
<p>The above snippet declares all of the methods in the trait <code>Compare</code> for the type <code>u64</code>. Now, we have access to both the <code>equals</code> and <code>not_equals</code> methods for <code>u64</code>, as long as the trait <code>Compare</code> is in scope.</p>
<h2 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h2>
<p>When using multiple traits, scenarios often come up where one trait may require functionality from another trait. This is where supertraits come in as they allow you to require a trait when implementing another
trait (ie. a trait with a trait). A good example of this is the <code>Ord</code> trait of the <code>core</code> library of Sway. The <code>Ord</code> trait requires the <code>Eq</code> trait, so <code>Eq</code> is kept as a separate trait as one may decide to implement <code>Eq</code>
without implementing other parts of the <code>Ord</code> trait.</p>
<pre><code class="language-sway">
trait Eq {
    fn equals(self, b: Self) -&gt; bool;
}

trait Ord: Eq {
    fn gte(self, b: Self) -&gt; bool;
}

impl Ord for u64 {
    fn gte(self, b: Self) -&gt; bool {
        // As `Eq` is a supertrait of `Ord`, `Ord` can access the equals method
        self.equals(b) || self.gt(b)
    }
}
</code></pre>
<p>To require a supertrait, add a <code>:</code> after the trait name and then list the traits you would like to require and separate them with a <code>+</code>.</p>
<h3 id="abi-supertraits"><a class="header" href="#abi-supertraits">ABI supertraits</a></h3>
<p>ABIs can also have supertrait annotations:</p>
<pre><code class="language-sway">contract;

struct Foo {}
impl ABIsupertrait for Foo {
    fn foo() {}
}

trait ABIsupertrait {
    fn foo();
}

abi MyAbi : ABIsupertrait {
    fn bar();
} {
    fn baz() {
        Self::foo() // supertrait method usage
    }
}

impl ABIsupertrait for Contract {
    fn foo() {}
}

// The implementation of MyAbi for Contract must also implement ABIsupertrait
impl MyAbi for Contract {
    fn bar() {
        Self::foo() // supertrait method usage
    }
}
</code></pre>
<p>The implementation of <code>MyAbi</code> for <code>Contract</code> must also implement the <code>ABIsupertrait</code> trait. Methods in <code>ABIsupertrait</code> are not available externally, i.e. they're not actually contract methods, but they can be used in the actual contract methods, as shown in the example above.</p>
<p>ABI supertraits are intended to make contract implementations compositional, allowing combining orthogonal contract features using, for instance, libraries.</p>
<h2 id="associated-items"><a class="header" href="#associated-items">Associated Items</a></h2>
<p>Traits can declare different kinds of associated items in their interface surface:</p>
<ul>
<li><a href="advanced/traits.html#associated-functions">Functions</a></li>
<li><a href="advanced/traits.html#associated-constants">Constants</a></li>
</ul>
<h3 id="associated-functions"><a class="header" href="#associated-functions">Associated functions</a></h3>
<p>Associated functions in traits consist of just function signatures. This indicates that each implementation of the trait for a given type must define all the trait functions.</p>
<pre><code class="language-sway">trait Trait {
    fn associated_fn(self, b: Self) -&gt; bool;
}
</code></pre>
<h3 id="associated-constants-1"><a class="header" href="#associated-constants-1">Associated constants</a></h3>
<p>Associated constants are constants associated with a type.</p>
<pre><code class="language-sway">trait Trait {
    const ID: u32 = 0;
}
</code></pre>
<p>The initializer expression of an <a href="advanced/../basic/constants.html#associated-constants">associated constants</a> in a trait definition may be omitted to indicate that each implementation of the <code>trait</code> for a given type must specify an initializer:</p>
<pre><code class="language-sway">trait Trait {
    const ID: u32;
}
</code></pre>
<p>Check the <code>associated consts</code> section on <a href="advanced/../basic/constants.html">constants</a> page.</p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="custom-types-structs-enums"><a class="header" href="#custom-types-structs-enums">Custom Types (structs, enums)</a></h3>
<p>Often, libraries and APIs have interfaces that are abstracted over a type that implements a certain trait. It is up to the consumer of the interface to implement that trait for the type they wish to use with the interface. For example, let's take a look at a trait and an interface built off of it.</p>
<pre><code class="language-sway">library;

pub enum Suit {
    Hearts: (),
    Diamonds: (),
    Clubs: (),
    Spades: (),
}

pub trait Card {
    fn suit(self) -&gt; Suit;
    fn value(self) -&gt; u8;
}

fn play_game_with_deck&lt;T&gt;(a: Vec&lt;T&gt;) where T: Card {
    // insert some creative card game here
}
</code></pre>
<blockquote>
<p><strong>Note</strong> Trait constraints (i.e. using the <code>where</code> keyword) <a href="https://github.com/FuelLabs/sway/issues/970">have not yet been implemented</a></p>
</blockquote>
<p>Now, if you want to use the function <code>play_game_with_deck</code> with your struct, you must implement <code>Card</code> for your struct. Note that the following code example assumes a dependency <em>games</em> has been included in the <code>Forc.toml</code> file.</p>
<pre><code class="language-sway">script;

use games::*;

struct MyCard {
    suit: Suit,
    value: u8
}

impl Card for MyCard {
    fn suit(self) -&gt; Suit {
        self.suit
    }
    fn value(self) -&gt; u8 {
        self.value
    }
}

fn main() {
    let mut i = 52;
    let mut deck: Vec&lt;MyCard&gt; = Vec::with_capacity(50);
    while i &gt; 0 {
        i = i - 1;
        deck.push(MyCard { suit: generate_random_suit(), value: i % 4}
    }
    play_game_with_deck(deck);
}

fn generate_random_suit() -&gt; Suit {
  [ ... ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-and-trait-constraints"><a class="header" href="#generics-and-trait-constraints">Generics and Trait Constraints</a></h1>
<h2 id="generics-as-constraints"><a class="header" href="#generics-as-constraints">Generics as Constraints</a></h2>
<p>At a high level, Sway allows you to define constraints, or restrictions, that
allow you to strike a balance between writing abstract and reusable code and
enforcing compile-time checks to determine if the abstract code that you've
written is correct.</p>
<p>The &quot;abstract and reusable&quot; part largely comes from <a href="advanced/./generic_types.html">generic types</a> and the
&quot;enforcing compile-time checks&quot; part largely comes from trait constraints.
Generic types can be used with functions, structs, and enums (as we have seen in
this book), but they can also be used with traits.</p>
<h2 id="generic-traits"><a class="header" href="#generic-traits">Generic Traits</a></h2>
<p>Combining generic types with traits allows you to write abstract and reusable
traits that can be implemented for any number of data types.</p>
<p>For example, imagine that you want to write a trait for converting between
different types. This would be similar to Rust's <code>Into</code> and <code>From</code> traits. In
Sway your conversion trait would look something like:</p>
<pre><code class="language-sway">trait Convert&lt;T&gt; {
    fn from(t: T) -&gt; Self;
}
</code></pre>
<p>The trait <code>Convert</code> takes a generic type <code>T</code>. <code>Convert</code> has one method
<code>from</code>, which takes one parameter of type <code>T</code> and returns a <code>Self</code>. This means
that when you implement <code>Convert</code> for a data type, <code>from</code> will return the type
of that data type but will take as input the type that you define as <code>T</code>. Here
is an example:</p>
<pre><code class="language-sway">struct Square {
    width: u64,
}

struct Rectangle {
    width: u64,
    length: u64,
}

impl Convert&lt;Square&gt; for Rectangle {
    fn from(t: Square) -&gt; Self {
        Self {
            width: t.width,
            length: t.width,
        }
    }
}
</code></pre>
<p>In this example, you have two different data types, <code>Square</code> and <code>Rectangle</code>.
You know that all squares are rectangles and thus <code>Square</code> can convert into <code>Rectangle</code> (but not vice
versa) and thus you can implement the conversion trait for those types.</p>
<p>If we want to call these methods we can do so by:</p>
<pre><code class="language-sway">fn main() {
    let s = Square { width: 5 };
    let r = Rectangle::from(s);
}
</code></pre>
<h2 id="trait-constraints-1"><a class="header" href="#trait-constraints-1">Trait Constraints</a></h2>
<p>Trait constraints allow you to use generic types and traits to place constraints
on what abstract code you are willing to accept in your program as correct.
These constraints take the form of compile-time checks for correctness.</p>
<p>If we wanted to use trait constraints with our <code>Convert</code> trait from the previous
section we could do so like so:</p>
<pre><code class="language-sway">fn into_rectangle&lt;T&gt;(t: T) -&gt; Rectangle
where
    Rectangle: Convert&lt;T&gt;
{
    Rectangle::from(t)
}
</code></pre>
<p>This function allows you to take any generic data type <code>T</code> and convert it to the
type <code>Rectangle</code> <em>as long as <code>Convert&lt;T&gt;</code> is implemented for <code>Rectangle</code></em>.
Calling this function with a type <code>T</code> for which <code>Convert&lt;T&gt;</code> is not implemented
for <code>Rectangle</code> will fail Sway's compile-time checks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-assembly-in-sway"><a class="header" href="#inline-assembly-in-sway">Inline Assembly in Sway</a></h1>
<p>While many users will never have to touch assembly language while writing sway code, it is a powerful tool that enables many advanced use-cases (ie: optimizations, building libraries, etc).</p>
<h2 id="asm-block"><a class="header" href="#asm-block">ASM Block</a></h2>
<p>In Sway, the way we use assembly inline is to declare an asm block like this:</p>
<pre><code class="language-sway">asm() {...}
</code></pre>
<p>Declaring an <code>asm</code> block is similar to declaring a function.
We can specify register names to operate on as arguments, we can perform operations within the block, and we can return a value.
Here's an example showing what this might look like:</p>
<pre><code class="language-sway">pub fn add_1(num: u32) -&gt; u32 {
    asm(r1: num, r2) {
        add r2 r1 one;
        r2: u32
    }
}
</code></pre>
<p>An <code>asm</code> block can only return a single register. If you really need to return more than one value, you can modify a tuple. Here's an example showing how can implement this <code>(u64, u64)</code>:</p>
<pre><code class="language-sway">script;

fn adder(a: u64, b: u64, c: u64) -&gt; (u64, u64) {
    let empty_tuple = (0u64, 0u64);
    asm(output: empty_tuple, r1: a, r2: b, r3: c, r4, r5) {
        add  r4 r1 r2; // add a &amp; b and put the result in r4
        add  r5 r2 r3; // add b &amp; c and put the result in r5
        sw   output r4 i0; // store the word in r4 in output + 0 words
        sw   output r5 i1; // store the word in r5 in output + 1 word
        output: (u64, u64) // return both values
    }
}

fn main() -&gt; bool {
    let (first, second) = adder(1, 2, 3);
    assert(first == 3);
    assert(second == 5);
    true
}
</code></pre>
<p>Note that this is contrived example meant to demonstrate the syntax; there's absolutely no need to use assembly to add integers!</p>
<p>Note that in the above example:</p>
<ul>
<li>we initialized the register <code>r1</code> with the value of <code>num</code>.</li>
<li>we declared a second register <code>r2</code> (you may choose any register names you want).</li>
<li>we use the <code>add</code> opcode to add <code>one</code> to the value of <code>r1</code> and store it in <code>r2</code>.</li>
<li><code>one</code> is an example of a &quot;reserved register&quot;, of which there are 16 in total. Further reading on this is linked below under &quot;Semantics&quot;.</li>
<li>we return <code>r2</code> &amp; specify the return type as being u32 (the return type is u64 by default).</li>
</ul>
<p>An important note is that the <code>ji</code> and <code>jnei</code> opcodes are not available within an <code>asm</code> block. For those looking to introduce control flow to <code>asm</code> blocks, it is recommended to surround smaller chunks of <code>asm</code> with control flow (<code>if</code>, <code>else</code>, and <code>while</code>).</p>
<h2 id="helpful-links"><a class="header" href="#helpful-links">Helpful Links</a></h2>
<p>For examples of assembly in action, check out the <a href="https://github.com/FuelLabs/sway/tree/master/sway-lib-std">Sway standard library</a>.</p>
<p>For a complete list of all instructions supported in the FuelVM: <a href="https://fuellabs.github.io/fuel-specs/master/vm/instruction_set">Instructions</a>.</p>
<p>And to learn more about the FuelVM semantics: <a href="https://fuellabs.github.io/fuel-specs/master/vm#semantics">Semantics</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-collections"><a class="header" href="#common-collections">Common Collections</a></h1>
<p>Sway’s standard library includes a number of very useful data structures called collections. Most other data types represent one specific value, but collections can contain multiple values. Unlike the built-in array and tuple types which are allocated on the &quot;stack&quot; and cannot grow in size, the data these collections point to is stored either on the &quot;heap&quot; or in contract &quot;storage&quot;, which means the amount of data does not need to be known at compile time and can grow as the program runs. Each kind of collection has different capabilities and costs, and choosing an appropriate one for your current situation is a skill you’ll develop over time. In this chapter, we’ll discuss three collections that are used very often in Sway programs:</p>
<p>A vector on the heap allows you to store a variable number of values next to each other.</p>
<p>A storage vector is similar to a vector on the heap but uses persistent storage.</p>
<p>A storage map allows you to associate a value with a particular key.</p>
<p>We’ll discuss how to create and update vectors, storage vectors, and storage maps, as well as what makes each special.</p>
<ul>
<li><a href="common-collections/./vec.html">Vectors on the Heap</a></li>
<li><a href="common-collections/./storage_vec.html">Storage Vectors</a></li>
<li><a href="common-collections/./storage_map.html">Storage Maps</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors-on-the-heap"><a class="header" href="#vectors-on-the-heap">Vectors on the Heap</a></h1>
<p>The first collection type we’ll look at is <code>Vec&lt;T&gt;</code>, also known as a vector. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</p>
<p><code>Vec&lt;T&gt;</code> is included in the <a href="common-collections/../introduction/standard_library.html#standard-library-prelude">standard library prelude</a> which means that there is no need to import it manually.</p>
<h2 id="creating-a-new-vector"><a class="header" href="#creating-a-new-vector">Creating a New Vector</a></h2>
<p>To create a new empty vector, we call the <code>Vec::new</code> function, as shown below:</p>
<pre><code class="language-sway">    let v: Vec&lt;u64&gt; = Vec::new();
</code></pre>
<p>Note that we added a type annotation here. Because we aren’t inserting any values into this vector, the Sway compiler doesn’t know what kind of elements we intend to store. Vectors are implemented using generics which means that the <code>Vec&lt;T&gt;</code> type provided by the standard library can hold any type. When we create a vector to hold a specific type, we can specify the type within angle brackets. In the example above, we’ve told the Sway compiler that the <code>Vec&lt;T&gt;</code> in <code>v</code> will hold elements of the <code>u64</code> type.</p>
<h2 id="updating-a-vector"><a class="header" href="#updating-a-vector">Updating a Vector</a></h2>
<p>To create a vector and then add elements to it, we can use the <code>push</code> method, as shown below:</p>
<pre><code class="language-sway">    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
</code></pre>
<p>As with any variable, if we want to be able to change its value, we need to make it mutable using the <code>mut</code> keyword, as discussed in the section <a href="common-collections/../basics/variables.html#declaring-a-variable">Declaring a Variable</a>. The numbers we place inside are all of type <code>u64</code>, and the Sway compiler infers this from the data, so we don’t need the <code>Vec&lt;u64&gt;</code> annotation.</p>
<h2 id="reading-elements-of-vectors"><a class="header" href="#reading-elements-of-vectors">Reading Elements of Vectors</a></h2>
<p>To read a value stored in a vector at a particular index, you can use the <code>get</code> method as shown below:</p>
<pre><code class="language-sway">    let third = v.get(2);
    match third {
        Some(third) =&gt; log(third),
        None =&gt; revert(42),
    }
</code></pre>
<p>Note two details here. First, we use the index value of <code>2</code> to get the third element because vectors are indexed by number, starting at zero. Second, we get the third element by using the <code>get</code> method with the index passed as an argument, which gives us an <code>Option&lt;T&gt;</code>.</p>
<p>When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking. This is particularly useful if accessing an element beyond the range of the vector may happen occasionally under normal circumstances. Your code will then have logic to handle having either <code>Some(element)</code> or <code>None</code>. For example, the index could be coming as a contract method argument. If the argument passed is too large, the method <code>get</code> will return a <code>None</code> value, and the contract method may then decide to revert when that happens or return a meaningful error that tells the user how many items are in the current vector and give them another chance to pass a valid value.</p>
<h2 id="iterating-over-the-values-in-a-vector"><a class="header" href="#iterating-over-the-values-in-a-vector">Iterating over the Values in a Vector</a></h2>
<p>To access each element in a vector in turn, we would iterate through all of the valid indices using a <code>while</code> loop and the <code>len</code> method as shown below:</p>
<pre><code class="language-sway">    let mut i = 0;
    while i &lt; v.len() {
        log(v.get(i).unwrap());
        i += 1;
    }
</code></pre>
<p>Note two details here. First, we use the method <code>len</code> which returns the length of the vector. Second, we call the method <code>unwrap</code> to extract the <code>Option</code> returned by <code>get</code>. We know that <code>unwrap</code> will not fail (i.e. will not cause a revert) because each index <code>i</code> passed to <code>get</code> is known to be smaller than the length of the vector.</p>
<h2 id="using-an-enum-to-store-multiple-types"><a class="header" href="#using-an-enum-to-store-multiple-types">Using an Enum to store Multiple Types</a></h2>
<p>Vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need one type to represent elements of different types, we can define and use an enum!</p>
<p>For example, say we want to get values from a row in a table in which some of the columns in the row contain integers, some <code>b256</code> values, and some Booleans. We can define an enum whose variants will hold the different value types, and all the enum variants will be considered the same type: that of the enum. Then we can create a vector to hold that enum and so, ultimately, holds different types. We’ve demonstrated this below:</p>
<pre><code class="language-sway">    enum TableCell {
        Int: u64,
        B256: b256,
        Boolean: bool,
    }

    let mut row = Vec::new();
    row.push(TableCell::Int(3));
    row.push(TableCell::B256(0x0101010101010101010101010101010101010101010101010101010101010101));
    row.push(TableCell::Boolean(true));
</code></pre>
<p>Now that we’ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on <code>Vec&lt;T&gt;</code> by the standard library. For now, these can be found in the <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/vec.sw">source code for <code>Vec&lt;T&gt;</code></a>. For example, in addition to <code>push</code>, a <code>pop</code> method removes and returns the last element, a <code>remove</code> method removes and returns the element at some chosen index within the vector, an <code>insert</code> method inserts an element at some chosen index within the vector, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-vectors"><a class="header" href="#storage-vectors">Storage Vectors</a></h1>
<p>The second collection type we’ll look at is <code>StorageVec&lt;T&gt;</code>. Just like vectors on the heap (i.e. <code>Vec&lt;T&gt;</code>), storage vectors allow you to store more than one value in a single data structure where each value is assigned an index and can only store values of the same type. However, unlike <code>Vec&lt;T&gt;</code>, the elements of a <code>StorageVec</code> are stored in <em>persistent storage</em>, and consecutive elements are not necessarily stored in storage slots that have consecutive keys.</p>
<p>In order to use <code>StorageVec&lt;T&gt;</code>, you must first import <code>StorageVec</code> as follows:</p>
<pre><code class="language-sway">use std::storage::storage_vec::*;
</code></pre>
<p>Another major difference between <code>Vec&lt;T&gt;</code> and <code>StorageVec&lt;T&gt;</code> is that <code>StorageVec&lt;T&gt;</code> can only be used in a contract because only contracts are allowed to access persistent storage.</p>
<h2 id="creating-a-new-storage-vector"><a class="header" href="#creating-a-new-storage-vector">Creating a New Storage Vector</a></h2>
<p>To create a new empty storage vector, we have to declare the vector in a <code>storage</code> block as follows:</p>
<pre><code class="language-sway">    v: StorageVec&lt;u64&gt; = StorageVec {},
</code></pre>
<p>Just like any other storage variable, two things are required when declaring a <code>StorageVec</code>: a type annotation and an initializer. The initializer is just an empty struct of type <code>StorageVec</code> because <code>StorageVec&lt;T&gt;</code> itself is an empty struct! Everything that is interesting about <code>StorageVec&lt;T&gt;</code> is implemented in its methods.</p>
<p>Storage vectors, just like <code>Vec&lt;T&gt;</code>, are implemented using generics which means that the <code>StorageVec&lt;T&gt;</code> type provided by the standard library can hold any type. When we create a storage vector to hold a specific type, we can specify the type within angle brackets. In the example above, we’ve told the Sway compiler that the <code>StorageVec&lt;T&gt;</code> in <code>v</code> will hold elements of the <code>u64</code> type.</p>
<h2 id="updating-a-storage-vector"><a class="header" href="#updating-a-storage-vector">Updating a Storage Vector</a></h2>
<p>To add elements to a storage vector, we can use the <code>push</code> method, as shown below:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn push_to_storage_vec() {
        storage.v.push(5);
        storage.v.push(6);
        storage.v.push(7);
        storage.v.push(8);
    }
</code></pre>
<p>Note two details here. First, in order to use <code>push</code>, we need to first access the vector using the <code>storage</code> keyword. Second, because <code>push</code> requires accessing storage, a <code>storage</code> annotation is required on the ABI function that calls <code>push</code>. While it may seem that <code>#[storage(write)]</code> should be enough here, the <code>read</code> annotation is also required because each call to <code>push</code> requires <em>reading</em> (and then updating) the length of the storage vector which is also stored in persistent storage.</p>
<blockquote>
<p><strong>Note</strong>
The storage annotation is also required for any private function defined in the contract that tries to push into the vector.</p>
</blockquote>
<!-- markdownlint-disable-line MD028 -->
<blockquote>
<p><strong>Note</strong>
There is no need to add the <code>mut</code> keyword when declaring a <code>StorageVec&lt;T&gt;</code>. All storage variables are mutable by default.</p>
</blockquote>
<h2 id="reading-elements-of-storage-vectors"><a class="header" href="#reading-elements-of-storage-vectors">Reading Elements of Storage Vectors</a></h2>
<p>To read a value stored in a vector at a particular index, you can use the <code>get</code> method as shown below:</p>
<pre><code class="language-sway">    #[storage(read)]
    fn read_from_storage_vec() {
        let third = storage.v.get(2);
        match third {
            Some(third) =&gt; log(third.read()),
            None =&gt; revert(42),
        }
    }
</code></pre>
<p>Note three details here. First, we use the index value of <code>2</code> to get the third element because vectors are indexed by number, starting at zero. Second, we get the third element by using the <code>get</code> method with the index passed as an argument, which gives us an <code>Option&lt;StorageKey&lt;T&gt;&gt;</code>. Third, the ABI function calling <code>get</code> only requires the annotation <code>#[storage(read)]</code> as one might expect because <code>get</code> does not write to storage.</p>
<p>When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking. This is particularly useful if accessing an element beyond the range of the vector may happen occasionally under normal circumstances. Your code will then have logic to handle having either <code>Some(element)</code> or <code>None</code>. For example, the index could be coming as a contract method argument. If the argument passed is too large, the method <code>get</code> will return a <code>None</code> value, and the contract method may then decide to revert when that happens or return a meaningful error that tells the user how many items are in the current vector and give them another chance to pass a valid value.</p>
<h2 id="iterating-over-the-values-in-a-vector-1"><a class="header" href="#iterating-over-the-values-in-a-vector-1">Iterating over the Values in a Vector</a></h2>
<p>To access each element in a vector in turn, we would iterate through all of the valid indices using a <code>while</code> loop and the <code>len</code> method as shown below:</p>
<pre><code class="language-sway">    #[storage(read)]
    fn iterate_over_a_storage_vec() {
        let mut i = 0;
        while i &lt; storage.v.len() {
            log(storage.v.get(i).unwrap().read());
            i += 1;
        }
    }
</code></pre>
<p>Again, this is quite similar to iterating over the elements of a <code>Vec&lt;T&gt;</code> where we use the method <code>len</code> to return the length of the vector. We also call the method <code>unwrap</code> to extract the <code>Option</code> returned by <code>get</code> followed by a call to <code>read()</code> to actually read the stored value. We know that <code>unwrap</code> will not fail (i.e. will not cause a revert) because each index <code>i</code> passed to <code>get</code> is known to be smaller than the length of the vector.</p>
<h2 id="using-an-enum-to-store-multiple-types-1"><a class="header" href="#using-an-enum-to-store-multiple-types-1">Using an Enum to store Multiple Types</a></h2>
<p>Storage vectors, just like <code>Vec&lt;T&gt;</code>, can only store values that are the same type. Similarly to what we did for <code>Vec&lt;T&gt;</code> in the section <a href="common-collections/./vec.html#using-an-enum-to-store-multiple-types">Using an Enum to store Multiple Types</a>, we can define an enum whose variants will hold the different value types, and all the enum variants will be considered the same type: that of the enum. This is shown below:</p>
<pre><code class="language-sway">enum TableCell {
    Int: u64,
    B256: b256,
    Boolean: bool,
}
</code></pre>
<p>Then we can declare a storage vector in a <code>storage</code> block to hold that enum and so, ultimately, holds different types:</p>
<pre><code class="language-sway">    row: StorageVec&lt;TableCell&gt; = StorageVec {},
</code></pre>
<p>We can now push different enum variants to the storage vector as follows:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn push_to_multiple_types_storage_vec() {
        storage.row.push(TableCell::Int(3));
        storage.row.push(TableCell::B256(0x0101010101010101010101010101010101010101010101010101010101010101));
        storage.row.push(TableCell::Boolean(true));
    }
</code></pre>
<p>Now that we’ve discussed some of the most common ways to use storage vectors, be sure to review the API documentation for all the many useful methods defined on <code>StorageVec&lt;T&gt;</code> by the standard library. For now, these can be found in the <a href="https://github.com/FuelLabs/sway/blob/master/sway-lib-std/src/storage.sw">source code for <code>StorageVec&lt;T&gt;</code></a>. For example, in addition to <code>push</code>, a <code>pop</code> method removes and returns the last element, a <code>remove</code> method removes and returns the element at some chosen index within the vector, an <code>insert</code> method inserts an element at some chosen index within the vector, etc.</p>
<h2 id="nested-storage-vecs"><a class="header" href="#nested-storage-vecs">Nested Storage Vecs</a></h2>
<p>It is possible to nest storage vectors as follows:</p>
<pre><code class="language-sway">    nested_vec: StorageVec&lt;StorageVec&lt;u64&gt;&gt; = StorageVec {},
</code></pre>
<p>The nested vector can then be accessed as follows:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn access_nested_vec() {
        storage.nested_vec.push(StorageVec {});
        storage.nested_vec.push(StorageVec {});

        let mut inner_vec0 = storage.nested_vec.get(0).unwrap();
        let mut inner_vec1 = storage.nested_vec.get(1).unwrap();

        inner_vec0.push(0);
        inner_vec0.push(1);

        inner_vec1.push(2);
        inner_vec1.push(3);
        inner_vec1.push(4);

        assert(inner_vec0.len() == 2);
        assert(inner_vec0.get(0).unwrap().read() == 0);
        assert(inner_vec0.get(1).unwrap().read() == 1);
        assert(inner_vec0.get(2).is_none());

        assert(inner_vec1.len() == 3);
        assert(inner_vec1.get(0).unwrap().read() == 2);
        assert(inner_vec1.get(1).unwrap().read() == 3);
        assert(inner_vec1.get(2).unwrap().read() == 4);
        assert(inner_vec1.get(3).is_none());
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-maps-1"><a class="header" href="#storage-maps-1">Storage Maps</a></h1>
<p>Another important common collection is the storage map.</p>
<!-- This section should explain storage maps in Sway -->
<!-- storage_map:example:start -->
<p>The type <code>StorageMap&lt;K, V&gt;</code> from the standard library stores a mapping of keys of type <code>K</code> to values of type <code>V</code> using a hashing function, which determines how it places these keys and values into <em>storage slots</em>. This is similar to <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">Rust's <code>HashMap&lt;K, V&gt;</code></a> but with a few differences.</p>
<p>Storage maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type. For example, when building a ledger-based sub-currency smart contract, you could keep track of the balance of each wallet in a storage map in which each key is a wallet’s <code>Address</code> and the values are each wallet’s balance. Given an <code>Address</code>, you can retrieve its balance.</p>
<p>Similarly to <code>StorageVec&lt;T&gt;</code>, <code>StorageMap&lt;K, V&gt;</code> can only be used in a contract because only contracts are allowed to access persistent storage.</p>
<p><code>StorageMap&lt;T&gt;</code> is included in the <a href="common-collections/../introduction/standard_library.html#standard-library-prelude">standard library prelude</a> which means that there is no need to import it manually.</p>
<!-- storage_map:example:end -->
<h2 id="creating-a-new-storage-map"><a class="header" href="#creating-a-new-storage-map">Creating a New Storage Map</a></h2>
<p>To create a new empty storage map, we have to declare the map in a <code>storage</code> block as follows:</p>
<pre><code class="language-sway">    map: StorageMap&lt;Address, u64&gt; = StorageMap {},
</code></pre>
<!-- This section should explain how to implement storage maps in Sway -->
<!-- use_storage_maps:example:start -->
<p>Just like any other storage variable, two things are required when declaring a <code>StorageMap</code>: a type annotation and an initializer. The initializer is just an empty struct of type <code>StorageMap</code> because <code>StorageMap&lt;K, V&gt;</code> itself is an empty struct! Everything that is interesting about <code>StorageMap&lt;K, V&gt;</code> is implemented in its methods.</p>
<p>Storage maps, just like <code>Vec&lt;T&gt;</code> and <code>StorageVec&lt;T&gt;</code>, are implemented using generics which means that the <code>StorageMap&lt;K, V&gt;</code> type provided by the standard library can map keys of any type <code>K</code> to values of any type <code>V</code>. In the example above, we’ve told the Sway compiler that the <code>StorageMap&lt;K, V&gt;</code> in <code>map</code> will map keys of type <code>Address</code> to values of type <code>u64</code>.</p>
<!-- use_storage_maps:example:end -->
<h2 id="updating-a-storage-map"><a class="header" href="#updating-a-storage-map">Updating a Storage Map</a></h2>
<!-- This section should explain how to update storage maps in Sway -->
<!-- update_storage_maps:example:start -->
<p>To insert key-value pairs into a storage map, we can use the <code>insert</code> method.</p>
<!-- update_storage_maps:example:end -->
<p>For example:</p>
<pre><code class="language-sway">    #[storage(write)]
    fn insert_into_storage_map() {
        let addr1 = Address::from(0x0101010101010101010101010101010101010101010101010101010101010101);
        let addr2 = Address::from(0x0202020202020202020202020202020202020202020202020202020202020202);

        storage.map.insert(addr1, 42);
        storage.map.insert(addr2, 77);
    }
</code></pre>
<p>Note two details here. First, in order to use <code>insert</code>, we need to first access the storage map using the <code>storage</code> keyword. Second, because <code>insert</code> requires <em>writing</em> into storage, a <code>#[storage(write)]</code> annotation is required on the ABI function that calls <code>insert</code>.</p>
<blockquote>
<p><strong>Note</strong>
The storage annotation is also required for any private function defined in the contract that tries to insert into the map.</p>
</blockquote>
<!-- markdownlint-disable-line MD028 -->
<blockquote>
<p><strong>Note</strong>
There is no need to add the <code>mut</code> keyword when declaring a <code>StorageMap&lt;K, V&gt;</code>. All storage variables are mutable by default.</p>
</blockquote>
<h2 id="accessing-values-in-a-storage-map"><a class="header" href="#accessing-values-in-a-storage-map">Accessing Values in a Storage Map</a></h2>
<!-- This section should explain how to access storage map values in Sway -->
<!-- access_storage_maps:example:start -->
<p>We can get a value out of the storage map by providing its <code>key</code> to the <code>get</code> method.</p>
<!-- access_storage_maps:example:end -->
<p>For example:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn get_from_storage_map() {
        let addr1 = Address::from(0x0101010101010101010101010101010101010101010101010101010101010101);
        let addr2 = Address::from(0x0202020202020202020202020202020202020202020202020202020202020202);

        storage.map.insert(addr1, 42);
        storage.map.insert(addr2, 77);

        let value1 = storage.map.get(addr1).try_read().unwrap_or(0);
    }
</code></pre>
<p>Here, <code>value1</code> will have the value that's associated with the first address, and the result will be <code>42</code>. The <code>get</code> method returns an <code>Option&lt;V&gt;</code>; if there’s no value for that key in the storage map, <code>get</code> will return <code>None</code>. This program handles the <code>Option</code> by calling <code>unwrap_or</code> to set <code>value1</code> to zero if <code>map</code> doesn't have an entry for the key.</p>
<h2 id="storage-maps-with-multiple-keys"><a class="header" href="#storage-maps-with-multiple-keys">Storage Maps with Multiple Keys</a></h2>
<p>Maps with multiple keys can be implemented using tuples as keys. For example:</p>
<pre><code class="language-sway">    map_two_keys: StorageMap&lt;(b256, bool), b256&gt; = StorageMap {},
</code></pre>
<h2 id="nested-storage-maps"><a class="header" href="#nested-storage-maps">Nested Storage Maps</a></h2>
<p>It is possible to nest storage maps as follows:</p>
<pre><code class="language-sway">    nested_map: StorageMap&lt;u64, StorageMap&lt;u64, u64&gt;&gt; = StorageMap {},
</code></pre>
<p>The nested map can then be accessed as follows:</p>
<pre><code class="language-sway">    #[storage(read, write)]
    fn access_nested_map() {
        storage.nested_map.get(0).insert(1, 42);
        storage.nested_map.get(2).insert(3, 24);

        assert(storage.nested_map.get(0).get(1).read() == 42);
        assert(storage.nested_map.get(0).get(0).try_read().is_none()); // Nothing inserted here
        assert(storage.nested_map.get(2).get(3).read() == 24);
        assert(storage.nested_map.get(2).get(2).try_read().is_none()); // Nothing inserted here
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Sway aims to provide facilities for both unit testing and integration testing.</p>
<p><strong>Unit testing</strong> refers to &quot;in-language&quot; testing which can be triggered via the
<code>forc test</code> command. Sway unit testing is currently a high-priority
work-in-progress, you can follow along at <a href="https://github.com/FuelLabs/sway/issues/1832">this
issue</a>.</p>
<p><strong>Integration testing</strong> refers to the testing of your Sway project's integration
within some wider application. You can add integration testing to your Sway+Rust
projects today using the cargo generate template and Rust SDK.</p>
<ul>
<li><a href="testing/./unit-testing.html">Unit Testing</a></li>
<li><a href="testing/./testing-with-rust.html">Testing with Rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h1>
<!-- This section should explain unit testing in Sway -->
<!-- unit_test:example:start -->
<p>Forc provides built-in support for building and executing tests for a package.</p>
<p>Tests are written as free functions with the <code>#[test]</code> attribute.</p>
<!-- unit_test:example:end -->
<p>For example:</p>
<pre><code class="language-sway">#[test]
fn test_meaning_of_life() {
    assert(6 * 7 == 42);
}
</code></pre>
<p>Each test function is ran as if it were the entry point for a
<a href="testing/../sway-program-types/scripts.html">script</a>. Tests &quot;pass&quot; if they return
successfully, and &quot;fail&quot; if they revert or vice versa while <a href="testing/unit-testing.html#testing-failure">testing failure</a>.</p>
<p>If the project has failing tests <code>forc test</code> will exit with exit status <code>101</code>.</p>
<h2 id="building-and-running-tests"><a class="header" href="#building-and-running-tests">Building and Running Tests</a></h2>
<p>We can build and execute all tests within a package with the following:</p>
<pre><code class="language-console">forc test
</code></pre>
<p>The output should look similar to this:</p>
<pre><code class="language-console">  Compiled library &quot;core&quot;.
  Compiled library &quot;std&quot;.
  Compiled library &quot;lib_single_test&quot;.
  Bytecode size is 92 bytes.
   Running 1 tests
      test test_meaning_of_life ... ok (170.652µs)
   Result: OK. 1 passed. 0 failed. Finished in 1.564996ms.
</code></pre>
<p>Visit the <a href="testing/../forc/commands/forc_test.html"><code>forc test</code></a> command reference to find
the options available for <code>forc test</code>.</p>
<h2 id="testing-failure"><a class="header" href="#testing-failure">Testing Failure</a></h2>
<!-- This section should explain support for failing unit tests in Sway -->
<!-- unit_test_fail:example:start -->
<p>Forc supports testing failing cases for test functions declared with <code>#[test(should_revert)]</code>.</p>
<!-- unit_test_fail:example:end -->
<p>For example:</p>
<pre><code class="language-sway">#[test(should_revert)]
fn test_meaning_of_life() {
    assert(6 * 6 == 42);
}
</code></pre>
<p>It is also possible to specify an expected revert code, like the following example.</p>
<pre><code class="language-sway">#[test(should_revert = &quot;18446744073709486084&quot;)]
fn test_meaning_of_life() {
    assert(6 * 6 == 42);
}
</code></pre>
<p>Tests with <code>#[test(should_revert)]</code> considered to be passing if they are reverting.</p>
<h2 id="calling-contracts-1"><a class="header" href="#calling-contracts-1">Calling Contracts</a></h2>
<p>Unit tests can call contract functions an example for such calls can be seen below.</p>
<pre><code class="language-sway">contract;

abi MyContract {
    fn test_function() -&gt; bool;
}

impl MyContract for Contract {
    fn test_function() -&gt; bool {
        true
    }
}
</code></pre>
<p>To test the <code>test_function()</code>, a unit test like the following can be written.</p>
<pre><code class="language-sway">#[test]
fn test_success() {
    let caller = abi(MyContract, CONTRACT_ID);
    let result = caller.test_function {}();
    assert(result == true)
}
</code></pre>
<p>It is also possible to test failure with contract calls as well.</p>
<pre><code class="language-sway">#[test(should_revert)]
fn test_fail() {
    let caller = abi(MyContract, CONTRACT_ID);
    let result = caller.test_function {}();
    assert(result == false)
}
</code></pre>
<!-- This section should explain how the `CONTRACT_ID` variable works in Sway unit tests -->
<!-- contract_id:example:start -->
<blockquote>
<p><strong>Note:</strong> When running <code>forc test</code>, your contract will be built twice: first <em>without</em> unit tests in order to determine the contract's ID, then a second time <em>with</em> unit tests with the <code>CONTRACT_ID</code> provided to their namespace. This <code>CONTRACT_ID</code> can be used with the <code>abi</code> cast to enable contract calls within unit tests.</p>
</blockquote>
<!-- contract_id:example:end -->
<p>Unit tests can call methods of external contracts if those contracts are added as contract dependencies, i.e. in the the <a href="testing/../forc/manifest_reference.html#the-contract-dependencies-section"><code>contract-dependencies</code></a> section of the manifest file. An example of such calls is shown below:</p>
<pre><code class="language-sway">contract;

abi CallerContract {
    fn test_false() -&gt; bool;
}

impl CallerContract for Contract {
    fn test_false() -&gt; bool {
        false
    }
}

abi CalleeContract {
    fn test_true() -&gt; bool;
}

#[test]
fn test_multi_contract_calls() {
    let caller = abi(CallerContract, CONTRACT_ID);
    let callee = abi(CalleeContract, callee::CONTRACT_ID);

    let should_be_false = caller.test_false();
    let should_be_true = callee.test_true();
    assert(!should_be_false);
    assert(should_be_true);
}
</code></pre>
<p>Example <code>Forc.toml</code> for contract above:</p>
<pre><code class="language-toml">[project]
authors = [&quot;Fuel Labs &lt;contact@fuel.sh&gt;&quot;]
entry = &quot;main.sw&quot;
license = &quot;Apache-2.0&quot;
name = &quot;caller&quot;

[dependencies]
std = { path = &quot;../../../sway-lib-std/&quot; }

[contract-dependencies]
callee = { path = &quot;../callee&quot; }
</code></pre>
<h2 id="running-tests-in-parallel-or-serially"><a class="header" href="#running-tests-in-parallel-or-serially">Running Tests in Parallel or Serially</a></h2>
<!-- This section should explain how unit tests do not share storage -->
<!-- storage:example:start -->
<p>By default, all unit tests in your project are run in parallel. Note that this does not lead to any data races in storage because each unit test has its own storage space that is not shared by any other unit test.</p>
<!-- storage:example:end -->
<p>By default, <code>forc test</code> will use all the available threads in your system. To request that a specific number of threads be used, the flag <code>--test-threads &lt;val&gt;</code> can be provided to <code>forc test</code>.</p>
<pre><code class="language-console">forc test --test-threads 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-with-rust"><a class="header" href="#testing-with-rust">Testing with Rust</a></h1>
<p>A common use of Sway is for writing contracts or scripts that exist as part of a
wider Rust application. In order to test the interaction between our Sway code
and our Rust code we can add integration testing.</p>
<h2 id="adding-rust-integration-testing"><a class="header" href="#adding-rust-integration-testing">Adding Rust Integration Testing</a></h2>
<p>To add Rust integration testing to a Forc project we can use <a href="https://github.com/FuelLabs/sway/tree/master/templates/sway-test-rs">the <code>sway-test-rs</code>
cargo generate
template</a>.
This template makes it easy for Sway devs to add the boilerplate required when
setting up their Rust integration testing.</p>
<p>Let's add a Rust integration test to <a href="testing/../introduction/forc_project.html">the fresh project we created in the
introduction</a>.</p>
<h3 id="1-enter-the-project"><a class="header" href="#1-enter-the-project">1. Enter the project</a></h3>
<p>To recap, here's what our empty project looks like:</p>
<pre><code class="language-console">$ cd my-fuel-project
$ tree .
├── Forc.toml
└── src
    └── main.sw
</code></pre>
<h3 id="2-install-cargo-generate"><a class="header" href="#2-install-cargo-generate">2. Install <code>cargo generate</code></a></h3>
<p>We're going to add a Rust integration test harness using a cargo generate
template. Let's make sure we have the <code>cargo generate</code> command installed!</p>
<pre><code class="language-console">cargo install cargo-generate
</code></pre>
<blockquote>
<p><em><strong>Note</strong>: You can learn more about cargo generate by visiting <a href="https://github.com/cargo-generate/cargo-generate">its
repository</a>.</em></p>
</blockquote>
<h3 id="3-generate-the-test-harness"><a class="header" href="#3-generate-the-test-harness">3. Generate the test harness</a></h3>
<p>Let's generate the default test harness with the following:</p>
<pre><code class="language-console">cargo generate --init fuellabs/sway templates/sway-test-rs --name my-fuel-project --force
</code></pre>
<p><code>--force</code> forces your <code>--name</code> input to retain your desired casing for the <code>{{project-name}}</code>
placeholder in the template. Otherwise, <code>cargo-generate</code> automatically converts it to <code>kebab-case</code>.
With <code>--force</code>, this means that both <code>my_fuel_project</code> and <code>my-fuel-project</code> are valid project names,
depending on your needs.</p>
<p>If all goes well, the output should look as follows:</p>
<pre><code class="language-console">⚠️   Favorite `fuellabs/sway` not found in config, using it as a git repository: https://github.com/fuellabs/sway
🤷   Project Name : my-fuel-project
🔧   Destination: /home/user/path/to/my-fuel-project ...
🔧   Generating template ...
[1/3]   Done: Cargo.toml
[2/3]   Done: tests/harness.rs
[3/3]   Done: tests
🔧   Moving generated files into: `/home/user/path/to/my-fuel-project`...
✨   Done! New project created /home/user/path/to/my-fuel-project
</code></pre>
<p>Let's have a look at the result:</p>
<pre><code class="language-console">$ tree .
├── Cargo.toml
├── Forc.toml
├── src
│   └── main.sw
└── tests
    └── harness.rs
</code></pre>
<p>We have two new files!</p>
<ul>
<li>The <code>Cargo.toml</code> is the manifest for our new test harness and specifies the
required dependencies including <code>fuels</code> the Fuel Rust SDK.</li>
<li>The <code>tests/harness.rs</code> contains some boilerplate test code to get us started,
though doesn't call any contract methods just yet.</li>
</ul>
<h3 id="4-build-the-forc-project"><a class="header" href="#4-build-the-forc-project">4. Build the forc project</a></h3>
<p>Before running the tests, we need to build our contract so that the necessary
ABI, storage and bytecode artifacts are available. We can do so with <code>forc build</code>:</p>
<pre><code class="language-console">$ forc build
  Creating a new `Forc.lock` file. (Cause: lock file did not exist)
    Adding core
    Adding std git+https://github.com/fuellabs/sway?tag=v0.24.5#e695606d8884a18664f6231681333a784e623bc9
   Created new lock file at /home/user/path/to/my-fuel-project/Forc.lock
  Compiled library &quot;core&quot;.
  Compiled library &quot;std&quot;.
  Compiled contract &quot;my-fuel-project&quot;.
  Bytecode size is 60 bytes.
</code></pre>
<p>At this point, our project should look like the following:</p>
<pre><code class="language-console">$ tree
├── Cargo.toml
├── Forc.lock
├── Forc.toml
├── out
│   └── debug
│       ├── my-fuel-project-abi.json
│       ├── my-fuel-project.bin
│       └── my-fuel-project-storage_slots.json
├── src
│   └── main.sw
└── tests
    └── harness.rs
</code></pre>
<p>We now have an <code>out</code> directory with our required JSON files!</p>
<blockquote>
<p><em><strong>Note</strong>: This step may no longer be required in the future as we plan to
enable the integration testing to automatically build the artifacts as
necessary so that files like the ABI JSON are always up to date.</em></p>
</blockquote>
<h3 id="5-build-and-run-the-tests"><a class="header" href="#5-build-and-run-the-tests">5. Build and run the tests</a></h3>
<p>Now we're ready to build and run the default integration test.</p>
<pre><code class="language-console">$ cargo test
    Updating crates.io index
   Compiling version_check v0.9.4
   Compiling proc-macro2 v1.0.46
   Compiling quote v1.0.21
   ...
   Compiling fuels v0.24.0
   Compiling my-fuel-project v0.1.0 (/home/user/path/to/my-fuel-project)
    Finished test [unoptimized + debuginfo] target(s) in 1m 03s
     Running tests/harness.rs (target/debug/deps/integration_tests-373971ac377845f7)

running 1 test
test can_get_contract_id ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.36s
</code></pre>
<blockquote>
<p><em><strong>Note</strong>: The first time we run <code>cargo test</code>, cargo will spend some time
fetching and building the dependencies for Fuel's Rust SDK. This might take a
while, but only the first time!</em></p>
</blockquote>
<p>If all went well, we should see some output that looks like the above!</p>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h2>
<p>Now that we've learned how to setup Rust integration testing in our project,
let's try to write some of our own tests!</p>
<p>First, let's update our contract code with a simple counter example:</p>
<pre><code class="language-sway">contract;

abi TestContract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64;

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64;
}

storage {
    counter: u64 = 0,
}

impl TestContract for Contract {
    #[storage(write)]
    fn initialize_counter(value: u64) -&gt; u64 {
        storage.counter.write(value);
        value
    }

    #[storage(read, write)]
    fn increment_counter(amount: u64) -&gt; u64 {
        let incremented = storage.counter.read() + amount;
        storage.counter.write(incremented);
        incremented
    }
}
</code></pre>
<p>To test our <code>initialize_counter</code> and <code>increment_counter</code> contract methods from
the Rust test harness, we could update our <code>tests/harness.rs</code> file with the
following:</p>
<!--TODO add test here once examples are tested-->
<pre><code class="language-rust ignore">use fuels::{prelude::*, types::ContractId};

// Load abi from json
abigen!(TestContract, &quot;out/debug/my-fuel-project-abi.json&quot;);

async fn get_contract_instance() -&gt; (TestContract, ContractId) {
    // Launch a local network and deploy the contract
    let mut wallets = launch_custom_provider_and_get_wallets(
        WalletsConfig::new(
            Some(1),             /* Single wallet */
            Some(1),             /* Single coin (UTXO) */
            Some(1_000_000_000), /* Amount per coin */
        ),
        None,
    )
    .await;
    let wallet = wallets.pop().unwrap();

    let id = Contract::load_from(
        &quot;./out/debug/my-fuel-project.bin&quot;,
        LoadConfiguration::default().set_storage_configuration(
            StorageConfiguration::load_from(
                &quot;./out/debug/my-fuel-project-storage_slots.json&quot;,
            )
            .unwrap(),
        ),
    )
    .unwrap()
    .deploy(&amp;wallet, TxParameters::default())
    .await
    .unwrap();

    let instance = TestContract::new(id.to_string(), wallet);

    (instance, id.into())
}

#[tokio::test]
async fn initialize_and_increment() {
    let (contract_instance, _id) = get_contract_instance().await;
    // Now you have an instance of your contract you can use to test each function

    let result = contract_instance
        .methods()
        .initialize_counter(42)
        .call()
        .await
        .unwrap();

    assert_eq!(42, result.value);

    // Call `increment_counter()` method in our deployed contract.
    let result = contract_instance
        .methods()
        .increment_counter(10)
        .call()
        .await
        .unwrap();

    assert_eq!(52, result.value);
}</code></pre>
<p>Let's build our project once more and run the test:</p>
<pre><code class="language-console">forc build
</code></pre>
<pre><code class="language-console">$ cargo test
   Compiling my-fuel-project v0.1.0 (/home/mindtree/programming/sway/my-fuel-project)
    Finished test [unoptimized + debuginfo] target(s) in 11.61s
     Running tests/harness.rs (target/debug/deps/integration_tests-373971ac377845f7)

running 1 test
test initialize_and_increment ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.25s
</code></pre>
<p>When cargo runs our test, our test uses the SDK to spin up a local in-memory
Fuel network, deploy our contract to it, and call the contract methods via the
ABI.</p>
<p>You can add as many functions decorated with <code>#[tokio::test]</code> as you like, and
<code>cargo test</code> will automatically test each of them!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-frontend-development"><a class="header" href="#application-frontend-development">Application Frontend Development</a></h1>
<ul>
<li><a href="frontend/./typescript_sdk.html">TypeScript SDK</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-sdk"><a class="header" href="#typescript-sdk">TypeScript SDK</a></h1>
<p>The TypeScript SDK supports common tasks like:</p>
<ul>
<li>Deploying and calling contracts</li>
<li>Generating contract types with TypeChain</li>
<li>Building and sending transactions</li>
<li>Encoding and decoding contract ABI</li>
</ul>
<p>Refer <a href="https://fuellabs.github.io/fuels-ts">here</a> for full documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sway-reference"><a class="header" href="#sway-reference">Sway Reference</a></h1>
<ul>
<li><a href="reference/./compiler_intrinsics.html">Compiler Intrinsics</a></li>
<li><a href="reference/./attributes.html">Attributes</a></li>
<li><a href="reference/./style_guide.html">Style Guide</a></li>
<li><a href="reference/./known_issues_and_workarounds.html">Known Issues and Workarounds</a></li>
<li><a href="reference/./rust_differences.html">Differences from Rust</a></li>
<li><a href="reference/./solidity_differences.html">Differences from Solidity</a></li>
<li><a href="reference/./contributing_to_sway.html">Contributing to Sway</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-intrinsics"><a class="header" href="#compiler-intrinsics">Compiler Intrinsics</a></h1>
<p>The Sway compiler supports a list of intrinsics that perform various low level operations that are useful for building libraries. Compiler intrinsics should rarely be used but are preferred over <code>asm</code> blocks because they are type-checked and are safer overall. Below is a list of all available compiler intrinsics:</p>
<hr />
<pre><code class="language-sway">__size_of_val&lt;T&gt;(val: T) -&gt; u64
</code></pre>
<p><strong>Description:</strong> Return the size of type <code>T</code> in bytes.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__size_of&lt;T&gt;() -&gt; u64
</code></pre>
<p><strong>Description:</strong> Return the size of type <code>T</code> in bytes.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__size_of_str&lt;T&gt;() -&gt; u64
</code></pre>
<p><strong>Description:</strong> Return the size of type <code>T</code> in bytes. This intrinsic differs from <code>__size_of</code> in the case of <code>str</code> type where the actual length in bytes of the string is returned without padding the byte size to the next word alignment. When <code>T</code> is not a string <code>0</code> is returned.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__is_reference_type&lt;T&gt;() -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns <code>true</code> if <code>T</code> is a <em>reference type</em> and <code>false</code> otherwise.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__is_str_type&lt;T&gt;() -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns <code>true</code> if <code>T</code> is a str type and <code>false</code> otherwise.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__eq&lt;T&gt;(lhs: T, rhs: T) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns whether <code>lhs</code> and <code>rhs</code> are equal.</p>
<p><strong>Constraints:</strong> <code>T</code> is <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, or <code>raw_ptr</code>.</p>
<hr />
<pre><code class="language-sway">__gt&lt;T&gt;(lhs: T, rhs: T) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns whether <code>lhs</code> is greater than <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>.</p>
<hr />
<pre><code class="language-sway">__lt&lt;T&gt;(lhs: T, rhs: T) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns whether <code>lhs</code> is less than <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>.</p>
<hr />
<pre><code class="language-sway">__gtf&lt;T&gt;(index: u64, tx_field_id: u64) -&gt; T
</code></pre>
<p><strong>Description:</strong> Returns transaction field with ID <code>tx_field_id</code> at index <code>index</code>, if applicable. This is a wrapper around FuelVM's <a href="https://fuellabs.github.io/fuel-specs/master/vm/instruction_set#gtf-get-transaction-fields"><code>gtf</code> instruction</a>. The resuting field is cast to <code>T</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__addr_of&lt;T&gt;(val: T) -&gt; raw_ptr
</code></pre>
<p><strong>Description:</strong> Returns the address in memory where <code>val</code> is stored.</p>
<p><strong>Constraints:</strong> <code>T</code> is a reference type.</p>
<hr />
<pre><code class="language-sway">__state_load_word(key: b256) -&gt; u64
</code></pre>
<p><strong>Description:</strong> Reads and returns a single word from storage at key <code>key</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__state_load_quad(key: b256, ptr: raw_ptr, slots: u64) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Reads <code>slots</code> number of slots (<code>b256</code> each) from storage starting at key <code>key</code> and stores them in memory starting at address <code>ptr</code>. Returns a Boolean describing whether all the storage slots were previously set.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__state_store_word(key: b256, val: u64) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Stores a single word <code>val</code> into storage at key <code>key</code>. Returns a Boolean describing whether the store slot was previously set.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__state_store_quad(key: b256, ptr: raw_ptr, slots: u64) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Stores <code>slots</code> number of slots (<code>b256</code> each) starting at address <code>ptr</code> in memory into storage starting at key <code>key</code>. Returns a Boolean describing whether the first storage slot was previously set.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__log&lt;T&gt;(val: T)
</code></pre>
<p><strong>Description:</strong> Logs value <code>val</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__add&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Adds <code>lhs</code> and <code>rhs</code> and returns the result.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>.</p>
<hr />
<pre><code class="language-sway">__sub&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Subtracts <code>rhs</code> from <code>lhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>.</p>
<hr />
<pre><code class="language-sway">__mul&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Multiplies <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>.</p>
<hr />
<pre><code class="language-sway">__div&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Divides <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>.</p>
<hr />
<pre><code class="language-sway">__and&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Bitwise AND <code>lhs</code> and <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>.</p>
<hr />
<pre><code class="language-sway">__or&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Bitwise OR <code>lhs</code> and <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>.</p>
<hr />
<pre><code class="language-sway">__xor&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Bitwise XOR <code>lhs</code> and <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>.</p>
<hr />
<pre><code class="language-sway">__mod&lt;T&gt;(lhs: T, rhs: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Modulo of <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>.</p>
<hr />
<pre><code class="language-sway">__rsh&lt;T&gt;(lhs: T, rhs: u64) -&gt; T
</code></pre>
<p><strong>Description:</strong> Logical right shift of <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>.</p>
<hr />
<pre><code class="language-sway">__lsh&lt;T&gt;(lhs: T, rhs: u64) -&gt; T
</code></pre>
<p><strong>Description:</strong> Logical left shift of <code>lhs</code> by <code>rhs</code>.</p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>.</p>
<hr />
<pre><code class="language-sway">__revert(code: u64)
</code></pre>
<p><strong>Description:</strong> Reverts with error code <code>code</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__ptr_add(ptr: raw_ptr, offset: u64)
</code></pre>
<p><strong>Description:</strong> Adds <code>offset</code> to the raw value of pointer <code>ptr</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__ptr_sub(ptr: raw_ptr, offset: u64)
</code></pre>
<p><strong>Description:</strong> Subtracts <code>offset</code> to the raw value of pointer <code>ptr</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__smo&lt;T&gt;(recipient: b256, data: T, coins: u64)
</code></pre>
<p><strong>Description:</strong> Sends a message <code>data</code> of arbitrary type <code>T</code> and <code>coins</code> amount of the base asset to address <code>recipient</code>.</p>
<p><strong>Constraints:</strong> None.</p>
<hr />
<pre><code class="language-sway">__not(op: T) -&gt; T
</code></pre>
<p><strong>Description:</strong> Bitwise NOT of <code>op</code></p>
<p><strong>Constraints:</strong> <code>T</code> is an integer type, i.e. <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p>The Sway compiler supports a list of attributes that perform various operations that are useful for building, testing and documenting Sway programs. Below is a list of all available attributes:</p>
<h2 id="allow"><a class="header" href="#allow">Allow</a></h2>
<p>The <code>#[allow(dead_code)]</code> attribute overrides the check for dead code so that violations will go unreported.</p>
<h2 id="doc"><a class="header" href="#doc">Doc</a></h2>
<p>The <code>#[doc(..)]</code> attribute specifies documentation.</p>
<p>Line doc comments beginning with exactly three slashes <code>///</code>, are interpreted as a special syntax for doc attributes. That is, they are equivalent to writing <code>#[doc(&quot;...&quot;)]</code> around the body of the comment, i.e., <code>/// Foo</code> turns into <code>#[doc(&quot;Foo&quot;)]</code></p>
<p>Line comments beginning with <code>//!</code> are doc comments that apply to the module of the source file they are in. That is, they are equivalent to writing <code>#![doc(&quot;...&quot;)]</code> around the body of the comment. <code>//!</code> module level doc comments should be at the top of Sway files.</p>
<p>Documentation can be generated from doc attributes using <code>forc doc</code>.</p>
<h2 id="inline"><a class="header" href="#inline">Inline</a></h2>
<p>The inline attribute suggests that a copy of the attributed function should be placed in the caller, rather than generating code to call the function where it is defined.</p>
<blockquote>
<p><strong>Note</strong>: The Sway compiler automatically inlines functions based on internal heuristics. Incorrectly inlining functions can make the program slower, so this attribute should be used with care.</p>
</blockquote>
<p>The <code>#[inline(never)]</code> attribute <em>suggests</em> that an inline expansion should never be performed.</p>
<p>The <code>#[inline(always)]</code> attribute <em>suggests</em> that an inline expansion should always be performed.</p>
<blockquote>
<p><strong>Note</strong>: <code>#[inline(..)]</code> in every form is a hint, with no <em>requirements</em>
on the language to place a copy of the attributed function in the caller.</p>
</blockquote>
<h2 id="payable"><a class="header" href="#payable">Payable</a></h2>
<p>The lack of <code>#[payable]</code> implies the method is non-payable. When calling an ABI method that is non-payable, the compiler emits an error if the amount of coins forwarded with the call is not guaranteed to be zero. Note that this is strictly a compile-time check and does not incur any runtime cost.</p>
<h2 id="storage-1"><a class="header" href="#storage-1">Storage</a></h2>
<p>In Sway, functions are pure by default but can be opted into impurity via the <code>storage</code> function attribute. The <code>storage</code> attribute may take <code>read</code> and/or <code>write</code> arguments indicating which type of access the function requires.</p>
<p>The <code>#[storage(read)]</code> attribute indicates that a function requires read access to the storage.</p>
<p>The <code>#[storage(write)]</code> attribute indicates that a function requires write access to the storage.</p>
<p>More details in <a href="reference/../blockchain-development/purity.html">Purity</a>.</p>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<p>The <code>#[test]</code> attribute marks a function to be executed as a test.</p>
<p>The <code>#[test(should_revert)]</code> attribute marks a function to be executed as a test that should revert.</p>
<p>More details in <a href="reference/../testing/unit-testing.html">Unit Testing</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style-guide"><a class="header" href="#style-guide">Style Guide</a></h1>
<h2 id="capitalization"><a class="header" href="#capitalization">Capitalization</a></h2>
<!-- This section should explain the capitalization style guide -->
<!-- cap:example:start -->
<p>In Sway, structs, traits, and enums are <code>CapitalCase</code>. Modules, variables, and functions are <code>snake_case</code>, constants are <code>SCREAMING_SNAKE_CASE</code>. The compiler will warn you if your capitalization is ever unidiomatic.</p>
<!-- cap:example:end -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-issues-and-workarounds"><a class="header" href="#known-issues-and-workarounds">Known Issues and Workarounds</a></h1>
<h2 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway/issues/870">#870</a>: All <code>impl</code> blocks need to be defined before any of the functions they define can be called.  This includes sibling functions in the same <code>impl</code> declaration, i.e., functions in an <code>impl</code> can't call each other yet.</li>
</ul>
<h2 id="missing-features"><a class="header" href="#missing-features">Missing Features</a></h2>
<ul>
<li><a href="https://github.com/FuelLabs/sway/issues/1182">#1182</a> Arrays in a <code>storage</code> block are not yet supported. See the <a href="reference/../blockchain-development/storage.html#manual-storage-management">Manual Storage Management</a> section for details on how to use <code>store</code> and <code>get</code> from the standard library to manage storage slots directly. Note, however, that <code>StorageMap&lt;K, V&gt;</code> <em>does</em> support arbitrary types for <code>K</code> and <code>V</code> without any limitations.</li>
</ul>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<ul>
<li>No compiler optimization passes have been implemented yet, therefore bytecode will be more expensive and larger than it would be in production. Note that eventually the optimizer will support zero-cost abstractions, avoiding the need for developers to go down to inline assembly to produce optimal code.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="differences-from-solidity"><a class="header" href="#differences-from-solidity">Differences From Solidity</a></h1>
<p>This page outlines some of the critical differences between Sway and Solidity, and between the FuelVM and the EVM.</p>
<h2 id="underlying-virtual-machine"><a class="header" href="#underlying-virtual-machine">Underlying Virtual Machine</a></h2>
<p>The underlying virtual machine targeted by Sway is the FuelVM, specified <a href="https://github.com/FuelLabs/fuel-specs">here</a>. Solidity targets the Ethereum Virtual Machine (EVM), specified <a href="https://ethereum.github.io/yellowpaper/paper.pdf">here</a>.</p>
<h2 id="word-size"><a class="header" href="#word-size">Word Size</a></h2>
<p>Words in the FuelVM are 64 bits (8 bytes), rather than the 256 bits (32 bytes) of the EVM. Therefore, primitive integers only go up to <code>u64</code>, and hashes (the <code>b256</code> type) are not in registers but rather in memory. A <code>b256</code> is therefore a pointer to a 32-byte memory region containing the hash value.</p>
<h2 id="unsigned-integers-only"><a class="header" href="#unsigned-integers-only">Unsigned Integers Only</a></h2>
<p>Only unsigned integers are provided as primitives: <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>u64</code>. Signed integer arithmetic is not available in the FuelVM. Signed integers and signed integer arithmetic can be implemented in high-level libraries if needed.</p>
<h2 id="global-revert"><a class="header" href="#global-revert">Global Revert</a></h2>
<p>Panics in the FuelVM (called &quot;reverts&quot; in Solidity and the EVM) are global, i.e. they cannot be caught. A panic will completely and unconditionally revert the stateful effects of a transaction, minus gas used.</p>
<h2 id="default-safe-math"><a class="header" href="#default-safe-math">Default Safe Math</a></h2>
<!-- This section should explain safe math in Fuel vs EVM -->
<!-- safe_math:example:start -->
<p>Math in the FuelVM is by default safe (i.e. any overflow or exception is a panic). Safety checks are performed natively in the VM implementation, rather than at the bytecode level like <a href="https://docs.soliditylang.org/en/latest/080-breaking-changes.html#silent-changes-of-the-semantics">Solidity's default safe math</a>.</p>
<!-- safe_math:example:end -->
<h2 id="no-code-size-limit"><a class="header" href="#no-code-size-limit">No* Code Size Limit</a></h2>
<p>There is no practical code size limit to Sway contracts. The physical limit is governed by the <a href="https://fuellabs.github.io/fuel-specs/master/vm#parameters"><code>VM_MAX_RAM</code> VM parameter</a>, which at the time of writing is 64 MiB.</p>
<h2 id="account-types"><a class="header" href="#account-types">Account Types</a></h2>
<p>Account types in the FuelVM have type-safe wrappers around primitive <code>b256</code> hashes to clearly distinguish their respective types. The wrapper <code>Address</code> mirrors that of an EOA (Externally Owned Account) and has the ability to hold UTXOs in the context of the EVM. The other wrapper, <code>ContractId</code>, reflects that of a deployed contract in the EVM but cannot hold UTXOs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="differences-from-rust"><a class="header" href="#differences-from-rust">Differences From Rust</a></h1>
<p>Sway shares a lot with Rust, especially its syntax. Because they are so similar, you may be surprised or caught off guard when they differ. This page serves to outline, from a high level, some of the syntactic <em>gotchas</em> that you may encounter.</p>
<h2 id="enum-variant-syntax"><a class="header" href="#enum-variant-syntax">Enum Variant Syntax</a></h2>
<p>In Rust, enums generally take one of three forms: <em>unit</em> variants, which have no inner data, <em>struct</em> variants, which contain named fields, and <em>tuple</em> variants, which contain within them a tuple of data. If you are unfamiliar with these terms, this is what they look like:</p>
<pre><code class="language-rust ignore">// note to those skimming the docs: this is Rust syntax! Not Sway! Don't copy/paste this into a Sway program.

enum Foo {
    UnitVariant,
    TupleVariant(u32, u64, bool),
    StructVariant {
        field_one: bool,
        field_two: bool
    }
}</code></pre>
<p>In Sway, enums are simplified. Enums variants must all specify exactly one type. This type represents their interior data. This is actually isomorphic to what Rust offers, just with a different syntax. I'll now rewrite the above enum but with Sway syntax:</p>
<pre><code class="language-sway">// This is equivalent Sway syntax for the above Rust enum.
enum Foo {
    UnitVariant: (),
    TupleVariant: (u32, u64, bool),
    StructVariant: MyStruct,
}

struct MyStruct {
    field_one: bool,
    field_two: bool,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-sway"><a class="header" href="#contributing-to-sway">Contributing To Sway</a></h1>
<p>Thanks for your interest in contributing to Sway! This document outlines the process for installing and setting up the Sway toolchain for development, as well as some conventions on contributing to Sway.</p>
<p>If you run into any difficulties getting started, you can always ask questions on our <a href="https://forum.fuel.network/">Discourse</a>.</p>
<h2 id="building-and-setting-up-a-development-workspace"><a class="header" href="#building-and-setting-up-a-development-workspace">Building and setting up a development workspace</a></h2>
<p>See the <a href="reference/../introduction/index.html">introduction</a> section for instructions on installing and setting up the Sway toolchain.</p>
<h2 id="getting-the-repository"><a class="header" href="#getting-the-repository">Getting the repository</a></h2>
<ol>
<li>Visit the <a href="https://github.com/FuelLabs/sway">Sway</a> repo and fork the project.</li>
<li>Then clone your forked copy to your local machine and get to work.</li>
</ol>
<pre><code class="language-sh">git clone https://github.com/FuelLabs/sway
cd sway
</code></pre>
<h2 id="building-and-testing"><a class="header" href="#building-and-testing">Building and testing</a></h2>
<p>The following steps will run the sway test suite and ensure that everything is set up correctly.</p>
<p>First, open a new terminal and start <code>fuel-core</code> with:</p>
<pre><code class="language-sh">fuel-core
</code></pre>
<p>Then open a second terminal, cd into the <code>sway</code> repo and run:</p>
<pre><code class="language-sh">cargo run --bin test
</code></pre>
<p>After the test suite runs, you should see:</p>
<pre><code class="language-console">Tests passed.
_n_ tests run (0 skipped)
</code></pre>
<p>Congratulations! You've now got everything setup and are ready to start making contributions.</p>
<h2 id="finding-something-to-work-on"><a class="header" href="#finding-something-to-work-on">Finding something to work on</a></h2>
<p>There are many ways in which you may contribute to the Sway project, some of which involve coding knowledge and some which do not. A few examples include:</p>
<ul>
<li>Reporting bugs</li>
<li>Adding documentation to the Sway book</li>
<li>Adding new features or bugfixes for which there is already an open issue</li>
<li>Making feature requests</li>
</ul>
<p>Check out our <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22">Help Wanted</a>, <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22The+Sway+Book%22">Sway Book</a> or <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22">Good First Issue</a> issues to find a suitable task.</p>
<p>If you are planning something big, for example, related to multiple components or changes current behaviors, make sure to open an issue to discuss with us before starting on the implementation.</p>
<h2 id="contribution-flow"><a class="header" href="#contribution-flow">Contribution flow</a></h2>
<p>This is a rough outline of what a contributor's workflow looks like:</p>
<ul>
<li>Make sure what you want to contribute is already tracked as an issue.
<ul>
<li>We may discuss the problem and solution in the issue.</li>
</ul>
</li>
<li>Create a Git branch from where you want to base your work. This is usually master.</li>
<li>Write code, add test cases, and commit your work.</li>
<li>Run tests and make sure all tests pass.</li>
<li>If the PR contains any breaking changes, add the breaking label to your PR.</li>
<li>Push your changes to a branch in your fork of the repository and submit a pull request.
<ul>
<li>Make sure mention the issue, which is created at step 1, in the commit message.</li>
</ul>
</li>
<li>Your PR will be reviewed and some changes may be requested.
<ul>
<li>Once you've made changes, your PR must be re-reviewed and approved.</li>
<li>If the PR becomes out of date, you can use GitHub's 'update branch' button.</li>
<li>If there are conflicts, you can merge and resolve them locally. Then push to your PR branch.
Any changes to the branch will require a re-review.</li>
</ul>
</li>
<li>Our CI system (Github Actions) automatically tests all authorized pull requests.</li>
<li>Use Github to merge the PR once approved.</li>
</ul>
<p>Thanks for your contributions!</p>
<h3 id="linking-issues"><a class="header" href="#linking-issues">Linking issues</a></h3>
<p>Pull requests should be linked to at least one issue in the same repo.</p>
<p>If the pull request resolves the relevant issues, and you want GitHub to close these issues automatically after it merged into the default branch, you can use the syntax (<code>KEYWORD #ISSUE-NUMBER</code>) like this:</p>
<pre><code class="language-markdown">close #123
</code></pre>
<p>If the pull request links an issue but does not close it, you can use the keyword <code>ref</code> like this:</p>
<pre><code class="language-markdown">ref #456
</code></pre>
<p>Multiple issues should use full syntax for each issue and separate by a comma, like:</p>
<pre><code class="language-markdown">close #123, ref #456
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-reference"><a class="header" href="#forc-reference">Forc Reference</a></h1>
<p>Forc stands for Fuel Orchestrator. Forc provides a variety of tools and commands for developers working with the Fuel ecosystem, such as scaffolding a new project, formatting, running scripts, deploying contracts, testing contracts, and more. If you're coming from a Rust background, forc is similar to cargo.</p>
<p>If you are new to Forc, see the <a href="forc/../introduction/forc_project.html">Forc Project</a> introduction section.</p>
<p>For a comprehensive overview of the Forc CLI commands, see the <a href="forc/./commands/index.html">Commands</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest-reference"><a class="header" href="#manifest-reference">Manifest Reference</a></h1>
<p>The <code>Forc.toml</code> (the <em>manifest</em> file) is a compulsory file for each package and it is written in [TOML] format. <code>Forc.toml</code> consists of the following fields:</p>
<ul>
<li>
<p><a href="forc/manifest_reference.html#the-project-section"><code>[project]</code></a> — Defines a sway project.</p>
<ul>
<li><code>name</code> — The name of the project.</li>
<li><code>authors</code> — The authors of the project.</li>
<li><code>organization</code> — The organization of the project.</li>
<li><code>license</code>— The project license.</li>
<li><code>entry</code> — The entry point for the compiler to start parsing from.
<ul>
<li>For the recomended way of selecting an entry point of large libraries please take a look at: <a href="forc/./../sway-program-types/libraries.html">Libraries</a></li>
</ul>
</li>
<li><code>implicit-std</code> -  Controls whether provided <code>std</code> version (with the current <code>forc</code> version) will get added as a dependency <em>implicitly</em>. <em>Unless you know what you are doing, leave this as default.</em></li>
<li><code>forc-version</code> - The minimum forc version required for this project to work properly.</li>
</ul>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-dependencies-section"><code>[dependencies]</code></a> — Defines the dependencies.</p>
</li>
<li>
<p><code>[network]</code> — Defines a network for forc to interact with.</p>
<ul>
<li><code>url</code> — URL of the network.</li>
</ul>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-build-profile-section"><code>[build-profile]</code></a> - Defines the build profiles.</p>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-patch-section"><code>[patch]</code></a> - Defines the patches.</p>
</li>
<li>
<p><a href="forc/manifest_reference.html#the-contract-dependencies-section"><code>[contract-dependencies]</code></a> - Defines the contract dependencies.</p>
</li>
</ul>
<h2 id="the-project-section"><a class="header" href="#the-project-section">The <code>[project]</code> section</a></h2>
<p>An example <code>Forc.toml</code> is shown below. Under <code>[project]</code> the following fields are optional:</p>
<ul>
<li><code>authors</code></li>
<li><code>organization</code></li>
</ul>
<p>Also for the following fields, a default value is provided so omitting them is allowed:</p>
<ul>
<li><code>entry</code> - (default : <em>main.sw</em>)</li>
<li><code>implicit-std</code> - (default : <em>true</em>)</li>
</ul>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;
</code></pre>
<h2 id="the-dependencies-section"><a class="header" href="#the-dependencies-section">The <code>[dependencies]</code> section</a></h2>
<p>The following fields can be provided with a dependency:</p>
<ul>
<li><code>version</code> - Desired version of the dependency</li>
<li><code>path</code> - The path of the dependency (if it is local)</li>
<li><code>git</code> - The URL of the git repo hosting the dependency</li>
<li><code>branch</code> - The desired branch to fetch from the git repo</li>
<li><code>tag</code> - The desired tag to fetch from the git repo</li>
<li><code>rev</code> - The desired rev (i.e. commit hash) reference</li>
</ul>
<p>Please see <a href="forc/./dependencies.html">dependencies</a> for details</p>
<h2 id="the-network-section"><a class="header" href="#the-network-section">The <code>[network]</code> section</a></h2>
<p>For the following fields, a default value is provided so omitting them is allowed:</p>
<ul>
<li><code>URL</code> - (default: <em><a href="http://127.0.0.1:4000">http://127.0.0.1:4000</a></em>)</li>
</ul>
<h2 id="the-build-profile-section"><a class="header" href="#the-build-profile-section">The <code>[build-profile.*]</code> section</a></h2>
<p>The <code>[build-profile]</code> tables provide a way to customize compiler settings such as debug options.</p>
<p>The following fields can be provided for a build-profile:</p>
<ul>
<li><code>print-ast</code> - Whether to print out the generated AST or not, defaults to false.</li>
<li><code>print-dca-graph</code> - Whether to print out the computed DCA graph (in GraphViz DOT format), defaults to false.</li>
<li><code>print-dca-graph-url-format</code> - The URL format to be used in the generated DOT file, an example for vscode would be: &quot;vscode://file/{path}:{line}:{col}&quot;</li>
<li><code>print-ir</code> - Whether to compile to bytecode (false) or to print out the generated IR (true), defaults to false.</li>
<li><code>print-finalized-asm</code> - Whether to compile to bytecode (false) or to print out the generated ASM (true), defaults to false.</li>
<li><code>print-intermediate-asm</code> - Whether to compile to bytecode (false) or to print out the generated ASM (true), defaults to false.</li>
<li><code>terse</code> - Terse mode. Limited warning and error output, defaults to false.</li>
<li><code>time_phases</code> - Whether to output the time elapsed over each part of the compilation process, defaults to false.</li>
<li><code>include_tests</code> -  Whether or not to include test functions in parsing, type-checking and codegen, this is set to true by invocations like <code>forc test</code>, defaults to false.</li>
<li><code>json_abi_with_callpaths</code> - Whether to json abi with callpaths instead of names for struct and enums, defaults to false.</li>
<li><code>error_on_warnings</code> - Whether to treat errors as warnings, defaults to false.</li>
</ul>
<p>There are two default <code>[build-profile]</code> available with every manifest file. These are <code>debug</code> and <code>release</code> profiles. If you want to override these profiles, you can provide them explicitly in the manifest file like the following example:</p>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;

[build-profile.debug]
print-finalized-asm = false
print-intermediate-asm = false
print-ir = false
terse = false

[build-profile.release]
print-finalized-asm = false 
print-intermediate-asm = false
print-ir = false
terse = true
</code></pre>
<p>Since <code>release</code> and <code>debug</code> implicitly included in every manifest file, you can use them by just passing <code>--release</code> or by not passing anything (debug is default). For using a user defined build profile there is <code>--build-profile &lt;profile name&gt;</code> option available to the relevant commands. (For an example see <a href="forc/../forc/commands/forc_build.html">forc-build</a>)</p>
<p>Note that providing the corresponding cli options (like <code>--finalized-asm</code>) will override the selected build profile. For example if you pass both <code>--release</code> and <code>--finalized-asm</code>, release build profile is omitted and resulting build profile would have a structure like the following:</p>
<pre><code class="language-toml">print-ast = false
print-ir = false
print-finalized-asm = false
print-intermediate-asm = false
terse = false
time-phases = false
include-tests = false
json-abi-with-callpaths = false
error-on-warnings = false
experimental-private-modules = false
</code></pre>
<h2 id="the-patch-section"><a class="header" href="#the-patch-section">The <code>[patch]</code> section</a></h2>
<p>The [patch] section of <code>Forc.toml</code> can be used to override dependencies with other copies. The example provided below patches <a href="https://github.com/fuellabs/sway">https://github.com/fuellabs/sway</a> source with master branch of the same repo.</p>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;

[dependencies]

[patch.'https://github.com/fuellabs/sway']
std = { git = &quot;https://github.com/fuellabs/sway&quot;, branch = &quot;test&quot; }
</code></pre>
<p>In the example above, <code>std</code> is patched with the <code>test</code> branch from <code>std</code> repo. You can also patch git dependencies with dependencies defined with a path.</p>
<pre><code class="language-toml">[patch.'https://github.com/fuellabs/sway']
std = { path = &quot;/path/to/local_std_version&quot; }
</code></pre>
<p>Just like <code>std</code> or <code>core</code> you can also patch dependencies you declared with a git repo.</p>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;

[dependencies]
foo = { git = &quot;https://github.com/foo/foo&quot;, branch = &quot;master&quot; }

[patch.'https://github.com/foo']
foo = { git = &quot;https://github.com/foo/foo&quot;, branch = &quot;test&quot; }
</code></pre>
<p>Note that each key after the <code>[patch]</code> is a URL of the source that is being patched.</p>
<h2 id="the-contract-dependencies-section"><a class="header" href="#the-contract-dependencies-section">The <code>[contract-dependencies]</code> section</a></h2>
<p>The <code>[contract-dependenices]</code> table can be used to declare contract dependencies for a Sway contract or script. Contract dependencies are the set of contracts that our contract or script may interact with. Declaring <code>[contract-dependencies]</code> makes it easier to refer to contracts in your Sway source code without having to manually update IDs each time a new version is deployed. Instead, we can use forc to pin and update contract dependencies just like we do for regular library dependencies.</p>
<p>Contracts declared under <code>[contract-dependencies]</code> are built and pinned just like regular <code>[dependencies]</code> however rather than importing each contract dependency's entire public namespace we instead import their respective contract IDs as <code>CONTRACT_ID</code> constants available via each contract dependency's namespace root. This means you can use a contract dependency's ID as if it were declared as a <code>pub const</code> in the root of the contract dependency package as demonstrated in the example below.</p>
<p>Entries under <code>[contract-dependencies]</code> can be declared in the same way that <code>[dependencies]</code> can be declared. That is, they can refer to the <code>path</code> or <code>git</code> source of another contract. Note that entries under <code>[contract-dependencies]</code> must refer to contracts and will otherwise produce an error.</p>
<p>Example <code>Forc.toml</code>:</p>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
organization = &quot;Fuel_Labs&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;

[contract-dependencies]
foo = { path = &quot;../foo&quot; }
</code></pre>
<p>Example usage:</p>
<pre><code class="language-sway">script;

fn main() {
  let foo_id = foo::CONTRACT_ID;
}
</code></pre>
<p>Because the ID of a contract is computed deterministically, rebuilding the same contract would always result in the same contract ID. Since two contracts with same contract ID cannot be deployed on the blockchain, a &quot;salt&quot; factor is needed to modify the contract ID. For each contract dependency declared under <code>[contract-dependencies]</code>, <code>salt</code> can be specified. An example is shown below:</p>
<pre><code class="language-toml">[contract-dependencies]
foo = { path = &quot;../foo&quot;, salt = &quot;0x1000000000000000000000000000000000000000000000000000000000000000&quot; }
</code></pre>
<p>For contract dependencies that do not specify any value for <code>salt</code>, a default of all zeros for <code>salt</code> is implicitly applied.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspaces"><a class="header" href="#workspaces">Workspaces</a></h1>
<p>A <em>workspace</em> is a collection of one or more packages, namely <em>workspace members</em>, that are managed together.</p>
<p>The key points for workspaces are:</p>
<ul>
<li>Common <code>forc</code> commands available for a single package can also be used for a workspace, like <code>forc build</code> or <code>forc deploy</code>.</li>
<li>All packages share a common <code>Forc.lock</code> file which resides in the root directory of the workspace.</li>
</ul>
<p>Workspace manifests are declared within <code>Forc.toml</code> files and support the following fields:</p>
<ul>
<li><a href="forc/workspaces.html#the-members-field"><code>members</code></a> - Packages to include in the workspace.</li>
<li><a href="forc/workspaces.html#the-patch-section"><code>[patch]</code></a> - Defines the patches.</li>
</ul>
<p>An empty workspace can be created with <code>forc new --workspace</code> or <code>forc init --workspace</code>.</p>
<h2 id="the-members-field"><a class="header" href="#the-members-field">The <code>members</code> field</a></h2>
<p>The <code>members</code> field defines which packages are members of the workspace:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;member1&quot;, &quot;path/to/member2&quot;]
</code></pre>
<p>The <code>members</code> field accepts entries to be given in relative path with respect to the workspace root.
Packages that are located within a workspace directory but are <em>not</em> contained within the <code>members</code> set are ignored.</p>
<h2 id="the-patch-section-1"><a class="header" href="#the-patch-section-1">The <code>[patch]</code> section</a></h2>
<p>The <code>[patch]</code> section can be used to override any dependency in the workspace dependency graph. The usage is the same with package level <code>[patch]</code> section and details can be seen <a href="forc/./manifest_reference.html#the-patch-section">here</a>.</p>
<p>It is not allowed to declare patch table in member of a workspace if the workspace manifest file contains a patch table.</p>
<p>Example:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;member1&quot;, &quot;path/to/member2&quot;]


[patch.'https://github.com/fuellabs/sway']
std = { git = &quot;https://github.com/fuellabs/sway&quot;, branch = &quot;test&quot; }
</code></pre>
<p>In the above example each occurance of <code>std</code> as a dependency in the workspace will be changed with <code>std</code> from <code>test</code> branch of sway repo.</p>
<h2 id="some-forc-commands-that-support-workspaces"><a class="header" href="#some-forc-commands-that-support-workspaces">Some <code>forc</code> commands that support workspaces</a></h2>
<ul>
<li><code>forc build</code> - Builds an entire workspace.</li>
<li><code>forc deploy</code> - Builds and deploys all deployable members (i.e, contracts) of the workspace in the correct order.</li>
<li><code>forc run</code> - Builds and runs all scripts of the workspace.</li>
<li><code>forc check</code> - Checks all members of the workspace.</li>
<li><code>forc update</code> - Checks and updates workspace level <code>Forc.lock</code> file that is shared between workspace members.</li>
<li><code>forc clean</code> - Cleans all output artifacts for each member of the workspace.</li>
<li><code>forc fmt</code> - Formats all members of a workspace.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h1>
<p>Forc has a dependency management system which can pull packages using git and ipfs. This allows users to build and share Forc libraries.</p>
<h2 id="adding-a-dependency"><a class="header" href="#adding-a-dependency">Adding a dependency</a></h2>
<p>If your <code>Forc.toml</code> doesn't already have a <code>[dependencies]</code> table, add one. Below, list the package name alongside its source. Currently, <code>forc</code> supports <code>git</code>, <code>ipfs</code> and <code>path</code> sources.</p>
<p>If a <code>git</code> source is specified, <code>forc</code> will fetch the git repository at the given URL and then search for a <code>Forc.toml</code> for a package with the given name anywhere inside the git repository.</p>
<p>The following example adds a library dependency named <code>custom_lib</code>. For git dependencies you may optionally specify a <code>branch</code>, <code>tag</code>, or <code>rev</code> (i.e. commit hash) reference.</p>
<pre><code class="language-toml">[dependencies]
custom_lib = { git = &quot;https://github.com/FuelLabs/custom_lib&quot;, branch = &quot;master&quot; }
# custom_lib = { git = &quot;https://github.com/FuelLabs/custom_lib&quot;, tag = &quot;v0.0.1&quot; }
# custom_lib = { git = &quot;https://github.com/FuelLabs/custom_lib&quot;, rev = &quot;87f80bdf323e2d64e213895d0a639ad468f4deff&quot; }
</code></pre>
<p>Depending on a local library using <code>path</code>:</p>
<pre><code class="language-toml">[dependencies]
custom_lib = { path = &quot;../custom_lib&quot; }
</code></pre>
<p>For <code>ipfs</code> sources, <code>forc</code> will fetch the specified <code>cid</code> using either a local ipfs node or a public gateway. <code>forc</code> automatically tries to connect to local <code>ipfs</code> node and if it fails, fallbacks to using <code>https://ipfs.io/</code>, as a gateway.</p>
<p>The following example adds a dependency with an <code>ipfs</code> source.</p>
<pre><code class="language-toml">[dependencies]
custom_lib = { ipfs = &quot;QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG&quot; }
</code></pre>
<p>Once the package is added, running <code>forc build</code> will automatically download added dependencies.</p>
<h2 id="updating-dependencies"><a class="header" href="#updating-dependencies">Updating dependencies</a></h2>
<p>To update dependencies in your Forc directory you can run <code>forc update</code>. For <code>path</code> and <code>ipfs</code> dependencies this will have no effect. For <code>git</code> dependencies with a <code>branch</code> reference, this will update the project to use the latest commit for the given branch.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable MD041 -->
<p>Here are a list of commands available to forc:</p>
<ul>
<li><a href="forc/commands/./forc_addr2line.html">forc addr2line</a></li>
<li><a href="forc/commands/./forc_build.html">forc build</a></li>
<li><a href="forc/commands/./forc_check.html">forc check</a></li>
<li><a href="forc/commands/./forc_clean.html">forc clean</a></li>
<li><a href="forc/commands/./forc_completions.html">forc completions</a></li>
<li><a href="forc/commands/./forc_contract-id.html">forc contract-id</a></li>
<li><a href="forc/commands/./forc_init.html">forc init</a></li>
<li><a href="forc/commands/./forc_new.html">forc new</a></li>
<li><a href="forc/commands/./forc_parse-bytecode.html">forc parse-bytecode</a></li>
<li><a href="forc/commands/./forc_plugins.html">forc plugins</a></li>
<li><a href="forc/commands/./forc_predicate-root.html">forc predicate-root</a></li>
<li><a href="forc/commands/./forc_test.html">forc test</a></li>
<li><a href="forc/commands/./forc_update.html">forc update</a></li>
<li><a href="forc/commands/./forc_template.html">forc template</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-addr2line"><a class="header" href="#forc-addr2line">forc-addr2line</a></h1>
<p>Show location and context of an opcode address in its source file</p>
<h2 id="usage"><a class="header" href="#usage">USAGE:</a></h2>
<p>forc addr2line [OPTIONS] --sourcemap-path &lt;SOURCEMAP_PATH&gt; --opcode-index &lt;OPCODE_INDEX&gt;</p>
<h2 id="options"><a class="header" href="#options">OPTIONS:</a></h2>
<p><code>-c</code>, <code>--context</code> &lt;<em>CONTEXT</em>&gt;</p>
<p>How many lines of context to show [default: 2]</p>
<p><code>-g</code>, <code>--sourcemap-path</code> &lt;<em>SOURCEMAP_PATH</em>&gt;</p>
<p>Source file mapping in JSON format</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-i</code>, <code>--opcode-index</code> &lt;<em>OPCODE_INDEX</em>&gt;</p>
<p>Opcode index</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-S</code>, <code>--search-dir</code> &lt;<em>SEARCH_DIR</em>&gt;</p>
<p>Where to search for the project root [default: .]</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-build"><a class="header" href="#forc-build">forc-build</a></h1>
<p>Compile the current or target project.</p>
<p>The output produced will depend on the project's program type.</p>
<ul>
<li>
<p><code>script</code>, <code>predicate</code> and <code>contract</code> projects will produce their bytecode in binary format
<code>&lt;project-name&gt;.bin</code>.</p>
</li>
<li>
<p><code>script</code> projects will also produce a file containing the hash of the bytecode binary
<code>&lt;project-name&gt;-bin-hash</code> (using <code>fuel_cypto::Hasher</code>).</p>
</li>
<li>
<p><code>predicate</code> projects will also produce a file containing the <strong>root</strong> hash of the bytecode binary
<code>&lt;project-name&gt;-bin-root</code> (using <code>fuel_tx::Contract::root_from_code</code>).</p>
</li>
<li>
<p><code>contract</code> and <code>library</code> projects will also produce the public ABI in JSON format
<code>&lt;project-name&gt;-abi.json</code>.</p>
</li>
</ul>
<h2 id="usage-1"><a class="header" href="#usage-1">USAGE:</a></h2>
<p>forc build [OPTIONS]</p>
<h2 id="options-1"><a class="header" href="#options-1">OPTIONS:</a></h2>
<p><code>--ast</code> </p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>Name of the build profile to use.</p>
<p>If unspecified, forc will use debug build profile.</p>
<p><code>--build-target</code> &lt;<em>BUILD_TARGET</em>&gt;</p>
<p>Build target to use for code generation</p>
<p>[default: fuel]
[possible values: fuel, evm, midenvm]</p>
<p><code>--dca-graph</code> &lt;<em>DCA_GRAPH</em>&gt;</p>
<p>Print the computed Sway DCA graph. DCA graph is printed to the specified path. If
specified '' graph is printed to stdout</p>
<p><code>--dca-graph-url-format</code> &lt;<em>DCA_GRAPH_URL_FORMAT</em>&gt;</p>
<p>Specifies the url format to be used in the generated dot file.
Variables {path}, {line} {col} can be used in the provided format.
An example for vscode would be:
&quot;vscode://file/{path}:{line}:{col}&quot;</p>
<p><code>--error-on-warnings</code> </p>
<p>Treat warnings as errors</p>
<p><code>--finalized-asm</code> </p>
<p>Print the finalized ASM.</p>
<p>This is the state of the ASM with registers allocated and optimisations applied.</p>
<p><code>-g</code>, <code>--output-debug</code> &lt;<em>DEBUG_FILE</em>&gt;</p>
<p>If set, outputs source file mapping in JSON format</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>--intermediate-asm</code> </p>
<p>Print the generated ASM.</p>
<p>This is the state of the ASM prior to performing register allocation and other ASM
optimisations.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p><code>--ir</code> </p>
<p>Print the generated Sway IR (Intermediate Representation)</p>
<p><code>--json-abi</code> </p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option
JSON output will be &quot;minified&quot;, i.e. all on one line without whitespace</p>
<p><code>--json-abi-with-callpaths</code> </p>
<p>Outputs json abi with callpaths instead of names for struct and enums</p>
<p><code>--json-storage-slots</code> </p>
<p>By default the JSON for initial storage slots is formatted for human readability. By
using this option JSON output will be &quot;minified&quot;, i.e. all on one line without
whitespace</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>--locked</code> </p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs
to be updated, Forc will exit with an error</p>
<p><code>--metrics-outfile</code> &lt;<em>METRICS_OUTFILE</em>&gt;</p>
<p>Output compilation metrics into file</p>
<p><code>-o</code>, <code>--output-bin</code> &lt;<em>BIN_FILE</em>&gt;</p>
<p>If set, outputs a binary file representing the script bytes</p>
<p><code>--offline</code> </p>
<p>Offline mode, prevents Forc from using the network when managing dependencies. Meaning
it will only try to use previously downloaded dependencies</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which the sway compiler output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>--release</code> </p>
<p>Use release build plan. If a custom release plan is not specified, it is implicitly
added to the manifest file.</p>
<p>If --build-profile is also provided, forc omits this flag and uses provided
build-profile.</p>
<p><code>--reverse-order</code> </p>
<p>Output build errors and warnings in reverse order</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-t</code>, <code>--terse</code> </p>
<p>Terse mode. Limited warning and error output</p>
<p><code>--tests</code> </p>
<p>Also build all tests within the project</p>
<p><code>--time-phases</code> </p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output<!-- markdownlint-disable MD041 --></p>
<h2 id="example-3"><a class="header" href="#example-3">EXAMPLE</a></h2>
<p>Compile the sway files of the current project.</p>
<pre><code class="language-console">$ forc build
Compiled script &quot;my-fuel-project&quot;.
Bytecode size is 28 bytes.
</code></pre>
<p>The output produced will depend on the project's program type. Building script, predicate and contract projects will produce their bytecode in binary format <code>&lt;project-name&gt;.bin</code>. Building contracts and libraries will also produce the public ABI in JSON format <code>&lt;project-name&gt;-abi.json</code>.</p>
<p>By default, these artifacts are placed in the <code>out/</code> directory.</p>
<p>If a <code>Forc.lock</code> file did not yet exist, it will be created in order to pin each of the dependencies listed in <code>Forc.toml</code> to a specific commit or version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-check"><a class="header" href="#forc-check">forc-check</a></h1>
<p>Check the current or target project and all of its dependencies for errors.</p>
<p>This will essentially compile the packages without performing the final step of code generation,
which is faster than running forc build.</p>
<h2 id="usage-2"><a class="header" href="#usage-2">USAGE:</a></h2>
<p>forc check [OPTIONS] [BUILD_TARGET]</p>
<h2 id="args"><a class="header" href="#args">ARGS:</a></h2>
<p>&lt;<em>BUILD_TARGET</em>&gt;
Build target to use for code generation</p>
<p>[default: fuel]
[possible values: fuel, evm, midenvm]</p>
<h2 id="options-2"><a class="header" href="#options-2">OPTIONS:</a></h2>
<p><code>--disable-tests</code> </p>
<p>Disable checking unit tests</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>--locked</code> </p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs
to be updated, Forc will exit with an error</p>
<p><code>--offline</code> </p>
<p>Offline mode, prevents Forc from using the network when managing dependencies. Meaning
it will only try to use previously downloaded dependencies</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-t</code>, <code>--terse</code> </p>
<p>Terse mode. Limited warning and error output</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-clean"><a class="header" href="#forc-clean">forc-clean</a></h1>
<p>Removes the default forc compiler output artifact directory, i.e. <code>&lt;project-name&gt;/out</code></p>
<h2 id="usage-3"><a class="header" href="#usage-3">USAGE:</a></h2>
<p>forc clean [OPTIONS]</p>
<h2 id="options-3"><a class="header" href="#options-3">OPTIONS:</a></h2>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory
will be used</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-completions"><a class="header" href="#forc-completions">forc-completions</a></h1>
<p>Generate tab-completion scripts for your shell</p>
<h2 id="usage-4"><a class="header" href="#usage-4">USAGE:</a></h2>
<p>forc completions [OPTIONS] --shell <SHELL></p>
<h2 id="options-4"><a class="header" href="#options-4">OPTIONS:</a></h2>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-S</code>, <code>--shell</code> &lt;<em>SHELL</em>&gt;</p>
<p>Specify shell to enable tab-completion for</p>
<p>[possible values: zsh, bash, fish, powershell, elvish]</p>
<p>For more info:
https://fuellabs.github.io/sway/latest/forc/commands/forc_completions.html</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output<!-- markdownlint-disable MD041 --></p>
<h2 id="discussion"><a class="header" href="#discussion">DISCUSSION</a></h2>
<p>Enable tab completion for Bash, Fish, Zsh, or PowerShell
The script is output on <code>stdout</code>, allowing one to re-direct the
output to the file of their choosing. Where you place the file
will depend on which shell, and which operating system you are
using. Your particular configuration may also determine where
these scripts need to be placed.</p>
<p>Here are some common set ups for the three supported shells under
Unix and similar operating systems (such as GNU/Linux).</p>
<h3 id="bash"><a class="header" href="#bash">BASH</a></h3>
<p>Completion files are commonly stored in <code>/etc/bash_completion.d/</code> for
system-wide commands, but can be stored in
<code>~/.local/share/bash-completion/completions</code> for user-specific commands.
Run the command:</p>
<pre><code class="language-sh">mkdir -p ~/.local/share/bash-completion/completions
forc completions --shell=bash &gt;&gt; ~/.local/share/bash-completion/completions/forc
</code></pre>
<p>This installs the completion script. You may have to log out and
log back in to your shell session for the changes to take effect.</p>
<h3 id="bash-macoshomebrew"><a class="header" href="#bash-macoshomebrew">BASH (macOS/Homebrew)</a></h3>
<p>Homebrew stores bash completion files within the Homebrew directory.
With the <code>bash-completion</code> brew formula installed, run the command:</p>
<pre><code class="language-sh">mkdir -p $(brew --prefix)/etc/bash_completion.d
forc completions --shell=bash &gt; $(brew --prefix)/etc/bash_completion.d/forc.bash-completion
</code></pre>
<h3 id="fish"><a class="header" href="#fish">FISH</a></h3>
<p>Fish completion files are commonly stored in
<code>$HOME/.config/fish/completions</code>. Run the command:</p>
<pre><code class="language-sh">mkdir -p ~/.config/fish/completions
forc completions --shell=fish &gt; ~/.config/fish/completions/forc.fish
</code></pre>
<p>This installs the completion script. You may have to log out and
log back in to your shell session for the changes to take effect.</p>
<h3 id="zsh"><a class="header" href="#zsh">ZSH</a></h3>
<p>ZSH completions are commonly stored in any directory listed in
your <code>$fpath</code> variable. To use these completions, you must either
add the generated script to one of those directories, or add your
own to this list.</p>
<p>Adding a custom directory is often the safest bet if you are
unsure of which directory to use. First create the directory; for
this example we'll create a hidden directory inside our <code>$HOME</code>
directory:</p>
<pre><code class="language-sh">mkdir ~/.zfunc
</code></pre>
<p>Then add the following lines to your <code>.zshrc</code> just before
<code>compinit</code>:</p>
<pre><code class="language-sh">fpath+=~/.zfunc
</code></pre>
<p>Now you can install the completions script using the following
command:</p>
<pre><code class="language-sh">forc completions --shell=zsh &gt; ~/.zfunc/_forc
</code></pre>
<p>You must then either log out and log back in, or simply run</p>
<pre><code class="language-sh">exec zsh
</code></pre>
<p>for the new completions to take effect.</p>
<h3 id="custom-locations"><a class="header" href="#custom-locations">CUSTOM LOCATIONS</a></h3>
<p>Alternatively, you could save these files to the place of your
choosing, such as a custom directory inside your $HOME. Doing so
will require you to add the proper directives, such as <code>source</code>ing
inside your login script. Consult your shells documentation for
how to add such directives.</p>
<h3 id="powershell"><a class="header" href="#powershell">POWERSHELL</a></h3>
<p>The powershell completion scripts require PowerShell v5.0+ (which
comes with Windows 10, but can be downloaded separately for windows 7
or 8.1).</p>
<p>First, check if a profile has already been set</p>
<pre><code class="language-sh">Test-Path $profile
</code></pre>
<p>If the above command returns <code>False</code> run the following</p>
<pre><code class="language-sh">New-Item -path $profile -type file -force
</code></pre>
<p>Now open the file provided by <code>$profile</code> (if you used the
<code>New-Item</code> command it will be
<code>${env:USERPROFILE}\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</code></p>
<p>Next, we either save the completions file into our profile, or
into a separate file and source it inside our profile. To save the
completions into our profile simply use</p>
<pre><code class="language-sh">forc completions --shell=powershell &gt;&gt; ${env:USERPROFILE}\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-contract-id"><a class="header" href="#forc-contract-id">forc-contract-id</a></h1>
<p>Determine contract-id for a contract. For workspaces outputs all contract ids in the workspace</p>
<h2 id="usage-5"><a class="header" href="#usage-5">USAGE:</a></h2>
<p>forc contract-id [OPTIONS]</p>
<h2 id="options-5"><a class="header" href="#options-5">OPTIONS:</a></h2>
<p><code>--ast</code> </p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>Name of the build profile to use.</p>
<p>If unspecified, forc will use debug build profile.</p>
<p><code>--dca-graph</code> &lt;<em>DCA_GRAPH</em>&gt;</p>
<p>Print the computed Sway DCA graph. DCA graph is printed to the specified path. If
specified '' graph is printed to stdout</p>
<p><code>--dca-graph-url-format</code> &lt;<em>DCA_GRAPH_URL_FORMAT</em>&gt;</p>
<p>Specifies the url format to be used in the generated dot file.
Variables {path}, {line} {col} can be used in the provided format.
An example for vscode would be:
&quot;vscode://file/{path}:{line}:{col}&quot;</p>
<p><code>--error-on-warnings</code> </p>
<p>Treat warnings as errors</p>
<p><code>--finalized-asm</code> </p>
<p>Print the finalized ASM.</p>
<p>This is the state of the ASM with registers allocated and optimisations applied.</p>
<p><code>-g</code>, <code>--output-debug</code> &lt;<em>DEBUG_FILE</em>&gt;</p>
<p>If set, outputs source file mapping in JSON format</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>--intermediate-asm</code> </p>
<p>Print the generated ASM.</p>
<p>This is the state of the ASM prior to performing register allocation and other ASM
optimisations.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p><code>--ir</code> </p>
<p>Print the generated Sway IR (Intermediate Representation)</p>
<p><code>--json-abi</code> </p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option
JSON output will be &quot;minified&quot;, i.e. all on one line without whitespace</p>
<p><code>--json-abi-with-callpaths</code> </p>
<p>Outputs json abi with callpaths instead of names for struct and enums</p>
<p><code>--json-storage-slots</code> </p>
<p>By default the JSON for initial storage slots is formatted for human readability. By
using this option JSON output will be &quot;minified&quot;, i.e. all on one line without
whitespace</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>--locked</code> </p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs
to be updated, Forc will exit with an error</p>
<p><code>--metrics-outfile</code> &lt;<em>METRICS_OUTFILE</em>&gt;</p>
<p>Output compilation metrics into file</p>
<p><code>-o</code>, <code>--output-bin</code> &lt;<em>BIN_FILE</em>&gt;</p>
<p>If set, outputs a binary file representing the script bytes</p>
<p><code>--offline</code> </p>
<p>Offline mode, prevents Forc from using the network when managing dependencies. Meaning
it will only try to use previously downloaded dependencies</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which the sway compiler output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>--release</code> </p>
<p>Use release build plan. If a custom release plan is not specified, it is implicitly
added to the manifest file.</p>
<p>If --build-profile is also provided, forc omits this flag and uses provided
build-profile.</p>
<p><code>--reverse-order</code> </p>
<p>Output build errors and warnings in reverse order</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>--salt</code> &lt;<em>SALT</em>&gt;</p>
<p>Added salt used to derive the contract ID.</p>
<p>By default, this is
<code>0x0000000000000000000000000000000000000000000000000000000000000000</code>.</p>
<p><code>-t</code>, <code>--terse</code> </p>
<p>Terse mode. Limited warning and error output</p>
<p><code>--time-phases</code> </p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-init"><a class="header" href="#forc-init">forc-init</a></h1>
<p>Create a new Forc project in an existing directory</p>
<h2 id="usage-6"><a class="header" href="#usage-6">USAGE:</a></h2>
<p>forc init [OPTIONS]</p>
<h2 id="options-6"><a class="header" href="#options-6">OPTIONS:</a></h2>
<p><code>--contract</code> </p>
<p>The default program type, excluding all flags or adding this flag
creates a basic contract program</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>--library</code> </p>
<p>Create a package with a library target (src/lib.sw)</p>
<p><code>--name</code> &lt;<em>NAME</em>&gt;</p>
<p>Set the package name. Defaults to the directory name</p>
<p><code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>The directory in which the forc project will be initialized</p>
<p><code>--predicate</code> </p>
<p>Create a package with a predicate target (src/predicate.rs)</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>--script</code> </p>
<p>Create a package with a script target (src/main.sw)</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<p><code>--workspace</code> </p>
<p>Adding this flag creates an empty workspace<!-- markdownlint-disable MD041 --></p>
<h2 id="example-4"><a class="header" href="#example-4">EXAMPLE</a></h2>
<pre><code class="language-console">$ mkdir my-fuel-project
$ cd my-fuel-project
$ forc init
$ tree
.
├── Forc.toml
└── src
    └── main.sw
</code></pre>
<p><code>Forc.toml</code> is the Forc manifest file, containing information about the project and dependencies.</p>
<p>A <code>src/</code> directory is created, with a single <code>main.sw</code> Sway file in it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-new"><a class="header" href="#forc-new">forc-new</a></h1>
<p>Create a new Forc project at <code>&lt;path&gt;</code></p>
<h2 id="usage-7"><a class="header" href="#usage-7">USAGE:</a></h2>
<p>forc new [OPTIONS] <PATH></p>
<h2 id="args-1"><a class="header" href="#args-1">ARGS:</a></h2>
<p>&lt;<em>PATH</em>&gt;</p>
<p>The path at which the project directory will be created</p>
<h2 id="options-7"><a class="header" href="#options-7">OPTIONS:</a></h2>
<p><code>--contract</code> </p>
<p>The default program type. Excluding all flags or adding this flag
creates a basic contract program</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>--library</code> </p>
<p>Adding this flag creates an empty library program</p>
<p><code>--name</code> &lt;<em>NAME</em>&gt;</p>
<p>Set the package name. Defaults to the directory name</p>
<p><code>--predicate</code> </p>
<p>Adding this flag creates an empty predicate program</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>--script</code> </p>
<p>Adding this flag creates an empty script program</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<p><code>--workspace</code> </p>
<p>Adding this flag creates an empty workspace<!-- markdownlint-disable MD041 --></p>
<h2 id="example-5"><a class="header" href="#example-5">EXAMPLE</a></h2>
<pre><code class="language-console">$ forc new my-fuel-project
$ cd my-fuel-project
$ tree
.
├── Forc.toml
└── src
    └── main.sw
</code></pre>
<p><code>Forc.toml</code> is the Forc manifest file, containing information about the project and dependencies.</p>
<p>A <code>src/</code> directory is created, with a single <code>main.sw</code> Sway file in it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-parse-bytecode"><a class="header" href="#forc-parse-bytecode">forc-parse-bytecode</a></h1>
<p>Parse bytecode file into a debug format</p>
<h2 id="usage-8"><a class="header" href="#usage-8">USAGE:</a></h2>
<p>forc parse-bytecode [OPTIONS] &lt;FILE_PATH&gt;</p>
<h2 id="args-2"><a class="header" href="#args-2">ARGS:</a></h2>
<p>&lt;<em>FILE_PATH</em>&gt;</p>
<h2 id="options-8"><a class="header" href="#options-8">OPTIONS:</a></h2>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output<!-- markdownlint-disable MD041 --></p>
<h2 id="example-6"><a class="header" href="#example-6">EXAMPLE</a></h2>
<p>We can try this command with the initial project created using <code>forc init</code>, with the counter template:</p>
<pre><code class="language-sh">forc new --template counter counter
cd counter
forc build -o obj
</code></pre>
<pre><code class="language-console">counter$ forc parse-bytecode obj

  half-word   byte   op                   raw           notes
          0   0      JI(4)                90 00 00 04   conditionally jumps to byte 16
          1   4      NOOP                 47 00 00 00
          2   8      Undefined            00 00 00 00   data section offset lo (0)
          3   12     Undefined            00 00 00 c8   data section offset hi (200)
          4   16     LW(63, 12, 1)        5d fc c0 01
          5   20     ADD(63, 63, 12)      10 ff f3 00
         ...
         ...
         ...
         60   240    Undefined            00 00 00 00
         61   244    Undefined            fa f9 0d d3
         62   248    Undefined            00 00 00 00
         63   252    Undefined            00 00 00 c8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-plugins"><a class="header" href="#forc-plugins">forc-plugins</a></h1>
<p>Find all forc plugins available via <code>PATH</code>.</p>
<p>Prints information about each discovered plugin.</p>
<h2 id="usage-9"><a class="header" href="#usage-9">USAGE:</a></h2>
<p>forc plugins [OPTIONS]</p>
<h2 id="options-9"><a class="header" href="#options-9">OPTIONS:</a></h2>
<p><code>-d</code>, <code>--describe</code> </p>
<p>Prints the long description associated with each listed plugin</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-p</code>, <code>--paths</code> </p>
<p>Prints the absolute path to each discovered plugin</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-predicate-root"><a class="header" href="#forc-predicate-root">forc-predicate-root</a></h1>
<p>Determine predicate-root for a predicate. For workspaces outputs all predicate roots in the
workspace</p>
<h2 id="usage-10"><a class="header" href="#usage-10">USAGE:</a></h2>
<p>forc predicate-root [OPTIONS]</p>
<h2 id="options-10"><a class="header" href="#options-10">OPTIONS:</a></h2>
<p><code>--ast</code> </p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>Name of the build profile to use.</p>
<p>If unspecified, forc will use debug build profile.</p>
<p><code>--dca-graph</code> &lt;<em>DCA_GRAPH</em>&gt;</p>
<p>Print the computed Sway DCA graph. DCA graph is printed to the specified path. If
specified '' graph is printed to stdout</p>
<p><code>--dca-graph-url-format</code> &lt;<em>DCA_GRAPH_URL_FORMAT</em>&gt;</p>
<p>Specifies the url format to be used in the generated dot file.
Variables {path}, {line} {col} can be used in the provided format.
An example for vscode would be:
&quot;vscode://file/{path}:{line}:{col}&quot;</p>
<p><code>--error-on-warnings</code> </p>
<p>Treat warnings as errors</p>
<p><code>--finalized-asm</code> </p>
<p>Print the finalized ASM.</p>
<p>This is the state of the ASM with registers allocated and optimisations applied.</p>
<p><code>-g</code>, <code>--output-debug</code> &lt;<em>DEBUG_FILE</em>&gt;</p>
<p>If set, outputs source file mapping in JSON format</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>--intermediate-asm</code> </p>
<p>Print the generated ASM.</p>
<p>This is the state of the ASM prior to performing register allocation and other ASM
optimisations.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p><code>--ir</code> </p>
<p>Print the generated Sway IR (Intermediate Representation)</p>
<p><code>--json-abi</code> </p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option
JSON output will be &quot;minified&quot;, i.e. all on one line without whitespace</p>
<p><code>--json-abi-with-callpaths</code> </p>
<p>Outputs json abi with callpaths instead of names for struct and enums</p>
<p><code>--json-storage-slots</code> </p>
<p>By default the JSON for initial storage slots is formatted for human readability. By
using this option JSON output will be &quot;minified&quot;, i.e. all on one line without
whitespace</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>--locked</code> </p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs
to be updated, Forc will exit with an error</p>
<p><code>--metrics-outfile</code> &lt;<em>METRICS_OUTFILE</em>&gt;</p>
<p>Output compilation metrics into file</p>
<p><code>-o</code>, <code>--output-bin</code> &lt;<em>BIN_FILE</em>&gt;</p>
<p>If set, outputs a binary file representing the script bytes</p>
<p><code>--offline</code> </p>
<p>Offline mode, prevents Forc from using the network when managing dependencies. Meaning
it will only try to use previously downloaded dependencies</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which the sway compiler output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>--release</code> </p>
<p>Use release build plan. If a custom release plan is not specified, it is implicitly
added to the manifest file.</p>
<p>If --build-profile is also provided, forc omits this flag and uses provided
build-profile.</p>
<p><code>--reverse-order</code> </p>
<p>Output build errors and warnings in reverse order</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-t</code>, <code>--terse</code> </p>
<p>Terse mode. Limited warning and error output</p>
<p><code>--time-phases</code> </p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-test"><a class="header" href="#forc-test">forc-test</a></h1>
<p>Run the Sway unit tests for the current project.</p>
<p>NOTE: Previously this command was used to support Rust integration testing, however the provided
behaviour served no benefit over running <code>cargo test</code> directly. The proposal to change the behaviour
to support unit testing can be found at the following link:
https://github.com/FuelLabs/sway/issues/1833</p>
<p>Sway unit tests are functions decorated with the <code>#[test]</code> attribute. Each test is compiled as a
unique entry point for a single program and has access to the namespace of the module in which it is
declared.</p>
<p>Unit tests decorated with the <code>#[test(script)]</code> attribute that are declared within <code>contract</code>
projects may also call directly into their associated contract's ABI.</p>
<p>Upon successful compilation, test scripts are executed to their completion. A test is considered a
failure in the case that a revert (<code>rvrt</code>) instruction is encountered during execution. Otherwise,
it is considered a success.</p>
<h2 id="usage-11"><a class="header" href="#usage-11">USAGE:</a></h2>
<p>forc test [OPTIONS] [FILTER]</p>
<h2 id="args-3"><a class="header" href="#args-3">ARGS:</a></h2>
<p>&lt;<em>FILTER</em>&gt;
When specified, only tests containing the given string will be executed</p>
<h2 id="options-11"><a class="header" href="#options-11">OPTIONS:</a></h2>
<p><code>--ast</code> </p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>Name of the build profile to use.</p>
<p>If unspecified, forc will use debug build profile.</p>
<p><code>--build-target</code> &lt;<em>BUILD_TARGET</em>&gt;</p>
<p>Build target to use for code generation</p>
<p>[default: fuel]
[possible values: fuel, evm, midenvm]</p>
<p><code>--dca-graph</code> &lt;<em>DCA_GRAPH</em>&gt;</p>
<p>Print the computed Sway DCA graph. DCA graph is printed to the specified path. If
specified '' graph is printed to stdout</p>
<p><code>--dca-graph-url-format</code> &lt;<em>DCA_GRAPH_URL_FORMAT</em>&gt;</p>
<p>Specifies the url format to be used in the generated dot file.
Variables {path}, {line} {col} can be used in the provided format.
An example for vscode would be:
&quot;vscode://file/{path}:{line}:{col}&quot;</p>
<p><code>--error-on-warnings</code> </p>
<p>Treat warnings as errors</p>
<p><code>--filter-exact</code> </p>
<p>When specified, only the test exactly matching the given string will be executed</p>
<p><code>--finalized-asm</code> </p>
<p>Print the finalized ASM.</p>
<p>This is the state of the ASM with registers allocated and optimisations applied.</p>
<p><code>-g</code>, <code>--output-debug</code> &lt;<em>DEBUG_FILE</em>&gt;</p>
<p>If set, outputs source file mapping in JSON format</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>--intermediate-asm</code> </p>
<p>Print the generated ASM.</p>
<p>This is the state of the ASM prior to performing register allocation and other ASM
optimisations.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p><code>--ir</code> </p>
<p>Print the generated Sway IR (Intermediate Representation)</p>
<p><code>--json-abi</code> </p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option
JSON output will be &quot;minified&quot;, i.e. all on one line without whitespace</p>
<p><code>--json-abi-with-callpaths</code> </p>
<p>Outputs json abi with callpaths instead of names for struct and enums</p>
<p><code>--json-storage-slots</code> </p>
<p>By default the JSON for initial storage slots is formatted for human readability. By
using this option JSON output will be &quot;minified&quot;, i.e. all on one line without
whitespace</p>
<p><code>-l</code>, <code>--logs</code> </p>
<p>Print <code>Log</code> and <code>LogData</code> receipts for tests</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>--locked</code> </p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs
to be updated, Forc will exit with an error</p>
<p><code>--metrics-outfile</code> &lt;<em>METRICS_OUTFILE</em>&gt;</p>
<p>Output compilation metrics into file</p>
<p><code>-o</code>, <code>--output-bin</code> &lt;<em>BIN_FILE</em>&gt;</p>
<p>If set, outputs a binary file representing the script bytes</p>
<p><code>--offline</code> </p>
<p>Offline mode, prevents Forc from using the network when managing dependencies. Meaning
it will only try to use previously downloaded dependencies</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which the sway compiler output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>-r</code>, <code>--pretty-print</code> </p>
<p>Pretty-print the logs emiited from tests</p>
<p><code>--release</code> </p>
<p>Use release build plan. If a custom release plan is not specified, it is implicitly
added to the manifest file.</p>
<p>If --build-profile is also provided, forc omits this flag and uses provided
build-profile.</p>
<p><code>--reverse-order</code> </p>
<p>Output build errors and warnings in reverse order</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-t</code>, <code>--terse</code> </p>
<p>Terse mode. Limited warning and error output</p>
<p><code>--test-threads</code> &lt;<em>TEST_THREADS</em>&gt;</p>
<p>Number of threads to utilize when running the tests. By default, this is the number of
threads available in your system</p>
<p><code>--time-phases</code> </p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-update"><a class="header" href="#forc-update">forc-update</a></h1>
<p>Update dependencies in the Forc dependencies directory</p>
<h2 id="usage-12"><a class="header" href="#usage-12">USAGE:</a></h2>
<p>forc update [OPTIONS]</p>
<h2 id="options-12"><a class="header" href="#options-12">OPTIONS:</a></h2>
<p><code>-c</code>, <code>--check</code> </p>
<p>Checks if the dependencies have newer versions. Won't actually perform the update, will
output which ones are up-to-date and outdated</p>
<p><code>-d</code> &lt;<em>TARGET_DEPENDENCY</em>&gt;</p>
<p>Dependency to be updated. If not set, all dependencies will be updated</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-template"><a class="header" href="#forc-template">forc-template</a></h1>
<p>Create a new Forc project from a git template</p>
<h2 id="usage-13"><a class="header" href="#usage-13">USAGE:</a></h2>
<p>forc template [OPTIONS] &lt;PROJECT_NAME&gt;</p>
<h2 id="args-4"><a class="header" href="#args-4">ARGS:</a></h2>
<p>&lt;<em>PROJECT_NAME</em>&gt;</p>
<p>The name of the project that will be created</p>
<h2 id="options-13"><a class="header" href="#options-13">OPTIONS:</a></h2>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-L</code>, <code>--log-level</code> &lt;<em>LOG_LEVEL</em>&gt;</p>
<p>Set the log level</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silence all output</p>
<p><code>-t</code>, <code>--template-name</code> &lt;<em>TEMPLATE_NAME</em>&gt;</p>
<p>The name of the template that needs to be fetched and used from git repo provided</p>
<p><code>-u</code>, <code>--url</code> &lt;<em>URL</em>&gt;</p>
<p>The template url, should be a git repo [default: https://github.com/fuellabs/sway]</p>
<p><code>-v</code>, <code>--verbose</code> </p>
<p>Use verbose output<!-- markdownlint-disable MD041 --></p>
<h2 id="example-7"><a class="header" href="#example-7">EXAMPLE</a></h2>
<pre><code class="language-sh">forc template --url https://github.com/owner/template/ --project_name my_example_project
</code></pre>
<p>The command above fetches the <code>HEAD</code> of the <code>template</code> repo and searches for <code>Forc.toml</code> at the root of the fetched repo. It will fetch the repo and prepare a new <code>Forc.toml</code> with the new project name. Outputs everything to <code>current_dir/project_name</code>.</p>
<pre><code class="language-sh">forc template --url https://github.com/FuelLabs/sway --template_name counter --project_name my_example_project
</code></pre>
<p>The command above fetches the HEAD of the <code>sway</code> repo and searches for <code>counter</code> example inside it (there is an example called <code>counter</code> under <code>sway/examples</code>). It will fetch the <code>counter</code> example and prepare a new <code>Forc.toml</code> with the new project name. Outputs everything to <code>current_dir/project_name</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>Plugins can be used to extend <code>forc</code> with new commands that go beyond the native commands mentioned in the previous chapter. While the Fuel ecosystem provides a few commonly useful plugins (<code>forc-fmt</code>, <code>forc-client</code>, <code>forc-lsp</code>, <code>forc-explore</code>), anyone can write their own!</p>
<p>Let's install a plugin, <code>forc-explore</code>, and see what's underneath the plugin:</p>
<pre><code class="language-sh">cargo install forc-explore
</code></pre>
<p>Check that we have installed <code>forc-explore</code>:</p>
<pre><code class="language-console">$ forc plugins
Installed Plugins:
forc-explore
</code></pre>
<p><code>forc-explore</code> runs the Fuel Network Explorer, which you can run and check out for yourself:</p>
<pre><code class="language-console">$ forc explore
Fuel Network Explorer 0.1.1
Running server on http://127.0.0.1:3030
Server::run{addr=127.0.0.1:3030}: listening on http://127.0.0.1:3030
</code></pre>
<p>You can visit <a href="http://127.0.0.1:3030">http://127.0.0.1:3030</a> to check out the network explorer!</p>
<p>Note that some plugin crates can also provide more than one command. For example, installing the <code>forc-client</code> plugin provides the <code>forc deploy</code> and <code>forc run</code> commands. This is achieved by specifying multiple <code>[[bin]]</code> targets within the <code>forc-client</code> manifest.</p>
<h2 id="writing-your-own-plugin"><a class="header" href="#writing-your-own-plugin">Writing your own plugin</a></h2>
<p>We encourage anyone to write and publish their own <code>forc</code> plugin to enhance their development experience.</p>
<p>Your plugin must be named in the format <code>forc-&lt;MY_PLUGIN&gt;</code> and you may use the above template as a starting point. You can use <a href="https://docs.rs/clap/latest/clap/">clap</a> and add more subcommands, options and configurations to suit your plugin's needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-client"><a class="header" href="#forc-client">forc-client</a></h1>
<p>Forc plugin for interacting with a Fuel node.</p>
<h2 id="initializing-the-wallet-and-adding-accounts"><a class="header" href="#initializing-the-wallet-and-adding-accounts">Initializing the wallet and adding accounts</a></h2>
<p>If you don't have an initialized wallet or any account for your wallet you won't be able to sign transactions.</p>
<p>To create a wallet you can use <code>forc wallet new</code>. It will ask you to choose a password to encrypt your wallet. After the initialization is done you will have your mnemonic phrase.</p>
<p>After you have created a wallet, you can derive a new account by running <code>forc wallet account new</code>. It will ask your password to decrypt the wallet before deriving an account.</p>
<h2 id="signing-transactions-using-forc-wallet-cli"><a class="header" href="#signing-transactions-using-forc-wallet-cli">Signing transactions using <code>forc-wallet</code> CLI</a></h2>
<p>To submit the transactions created by <code>forc deploy</code> or <code>forc run</code>, you need to sign them first (unless you are using a client without UTXO validation). To sign a transaction you can use <code>forc-wallet</code> CLI. This section is going to walk you through the whole signing process.</p>
<p>By default <code>fuel-core</code> runs without UTXO validation, which means you can run unsigned transactions. This allows you to send invalid inputs to emulate different conditions.</p>
<p>If you want to run <code>fuel-core</code> with UTXO validation, you can pass <code>--utxo-validation</code> to <code>fuel-core run</code>. If UTXO validation is enabled, unsigned transactions will return an error.</p>
<p>To install <code>forc-wallet</code> please refer to <code>forc-wallet</code>'s <a href="https://github.com/FuelLabs/forc-wallet#forc-wallet">github repo</a>.</p>
<ol>
<li>Construct the transaction by using either <code>forc deploy</code> or <code>forc run</code>. To do so simply run <code>forc deploy</code> or <code>forc run</code> with your desired parameters. For a list of parameters please refer to the <a href="forc/plugins/forc_client/./forc_deploy">forc-deploy</a> or <a href="forc/plugins/forc_client/./forc_run">forc-run</a> section of the book. Once you run either command you will be asked the address of the wallet you are going to be signing with. After the address is given the transaction will be generated and you will be given a transaction ID. At this point CLI will actively wait for you to insert the signature.</li>
<li>Take the transaction ID generated in the first step and sign it with <code>forc wallet sign --account &lt;account_index&gt; tx-id &lt;transaction_id&gt;</code>. This will generate a signature.</li>
<li>Take the signature generated in the second step and provide it to <code>forc-deploy</code> (or <code>forc-run</code>). Once the signature is provided, the signed transaction will be submitted.</li>
</ol>
<h2 id="other-useful-commands-of-forc-wallet"><a class="header" href="#other-useful-commands-of-forc-wallet">Other useful commands of <code>forc-wallet</code></a></h2>
<ul>
<li>You can see a list of existing accounts with <code>accounts</code> command.</li>
</ul>
<pre><code class="language-sh">forc wallet accounts
</code></pre>
<ul>
<li>If you want to retrieve the address for an account by its index you can use <code>account</code> command.</li>
</ul>
<pre><code class="language-sh">forc wallet account &lt;account_index&gt;
</code></pre>
<blockquote>
<p>If you don't want to sign the transaction generated by <code>forc-deploy</code> or <code>forc-run</code> you can pass <code>--unsigned</code> to them.</p>
<pre><code class="language-sh">forc-deploy --unsigned
</code></pre>
<pre><code class="language-sh">forc-run --unsigned
</code></pre>
</blockquote>
<h2 id="interacting-with-the-testnet"><a class="header" href="#interacting-with-the-testnet">Interacting with the testnet</a></h2>
<p>While using <code>forc-deploy</code> or <code>forc-run</code> to interact with the testnet you need to pass the testnet end point with <code>--url</code></p>
<pre><code class="language-sh">forc-deploy --url https://node-beta-1.fuel.network/graphql:443
</code></pre>
<p>Since deploying and running projects on the testnet cost gas, you will need coins to pay for them. You can get some using the <a href="https://faucet-beta-1.fuel.network/">testnet faucet</a>.</p>
<p>Also the default value of the &quot;gas price&quot; parameter is 0 for both <code>forc-deploy</code> and <code>forc-run</code>. Without changing it you will get an error complaining about gas price being too low. While using testnet you can pass <code>--gas-price 1</code> to overcome this issue. So a complete command for deploying to the testnet would look like:</p>
<pre><code class="language-sh">forc-deploy --url https://node-beta-1.fuel.network/graphql:443 --gas-price 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-deploy"><a class="header" href="#forc-deploy">forc-deploy</a></h1>
<p>Build profile options</p>
<h2 id="usage-14"><a class="header" href="#usage-14">USAGE:</a></h2>
<p>forc deploy [OPTIONS] [SIGNING_KEY]</p>
<h2 id="args-5"><a class="header" href="#args-5">ARGS:</a></h2>
<p>&lt;<em>SIGNING_KEY</em>&gt;
Set the key to be used for signing</p>
<h2 id="options-14"><a class="header" href="#options-14">OPTIONS:</a></h2>
<p><code>--ast</code> </p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>Name of the build profile to use.</p>
<p>If unspecified, forc will use debug build profile.</p>
<p><code>--dca-graph</code> &lt;<em>DCA_GRAPH</em>&gt;</p>
<p>Print the computed Sway DCA graph. DCA graph is printed to the specified path. If
specified '' graph is printed to stdout</p>
<p><code>--dca-graph-url-format</code> &lt;<em>DCA_GRAPH_URL_FORMAT</em>&gt;</p>
<p>Specifies the url format to be used in the generated dot file.
Variables {path}, {line} {col} can be used in the provided format.
An example for vscode would be:
&quot;vscode://file/{path}:{line}:{col}&quot;</p>
<p><code>--default-salt</code> </p>
<p>Generate a default salt
(0x0000000000000000000000000000000000000000000000000000000000000000) for the contract.
Useful for CI, to create reproducable deployments</p>
<p><code>--error-on-warnings</code> </p>
<p>Treat warnings as errors</p>
<p><code>--finalized-asm</code> </p>
<p>Print the finalized ASM.</p>
<p>This is the state of the ASM with registers allocated and optimisations applied.</p>
<p><code>-g</code>, <code>--output-debug</code> &lt;<em>DEBUG_FILE</em>&gt;</p>
<p>If set, outputs source file mapping in JSON format</p>
<p><code>--gas-limit</code> &lt;<em>LIMIT</em>&gt;</p>
<p>Gas limit for the transaction</p>
<p>[default: 100000000]</p>
<p><code>--gas-price</code> &lt;<em>PRICE</em>&gt;</p>
<p>Gas price for the transaction</p>
<p>[default: 0]</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>--intermediate-asm</code> </p>
<p>Print the generated ASM.</p>
<p>This is the state of the ASM prior to performing register allocation and other ASM
optimisations.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p><code>--ir</code> </p>
<p>Print the generated Sway IR (Intermediate Representation)</p>
<p><code>--json-abi</code> </p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option
JSON output will be &quot;minified&quot;, i.e. all on one line without whitespace</p>
<p><code>--json-abi-with-callpaths</code> </p>
<p>Outputs json abi with callpaths instead of names for struct and enums</p>
<p><code>--json-storage-slots</code> </p>
<p>By default the JSON for initial storage slots is formatted for human readability. By
using this option JSON output will be &quot;minified&quot;, i.e. all on one line without
whitespace</p>
<p><code>--locked</code> </p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs
to be updated, Forc will exit with an error</p>
<p><code>--manual-signing</code> </p>
<p>Sign the deployment transaction manually</p>
<p><code>--maturity</code> &lt;<em>MATURITY</em>&gt;</p>
<p>Block height until which tx cannot be included</p>
<p>[default: 0]</p>
<p><code>--metrics-outfile</code> &lt;<em>METRICS_OUTFILE</em>&gt;</p>
<p>Output compilation metrics into file</p>
<p><code>--node-url</code> &lt;<em>NODE_URL</em>&gt;</p>
<p>The URL of the Fuel node to which we're submitting the transaction. If unspecified,
checks the manifest's <code>network</code> table, then falls back to [<code>crate::default::NODE_URL</code>]</p>
<p>[env: FUEL_NODE_URL=]</p>
<p><code>-o</code>, <code>--output-bin</code> &lt;<em>BIN_FILE</em>&gt;</p>
<p>If set, outputs a binary file representing the script bytes</p>
<p><code>--offline</code> </p>
<p>Offline mode, prevents Forc from using the network when managing dependencies. Meaning
it will only try to use previously downloaded dependencies</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which the sway compiler output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>--release</code> </p>
<p>Use release build plan. If a custom release plan is not specified, it is implicitly
added to the manifest file.</p>
<p>If --build-profile is also provided, forc omits this flag and uses provided
build-profile.</p>
<p><code>--reverse-order</code> </p>
<p>Output build errors and warnings in reverse order</p>
<p><code>--salt</code> &lt;<em>SALT</em>&gt;</p>
<p>Optional 256-bit hexadecimal literal(s) to redeploy contracts.</p>
<p>For a single contract, use <code>--salt &lt;SALT&gt;</code>, eg.: forc deploy --salt
0x0000000000000000000000000000000000000000000000000000000000000001</p>
<p>For a workspace with multiple contracts, use <code>--salt &lt;CONTRACT_NAME&gt;:&lt;SALT&gt;</code> to specify
a salt for each contract, eg.:</p>
<p>forc deploy --salt
contract_a:0x0000000000000000000000000000000000000000000000000000000000000001 --salt
contract_b:0x0000000000000000000000000000000000000000000000000000000000000002</p>
<p><code>-t</code>, <code>--terse</code> </p>
<p>Terse mode. Limited warning and error output</p>
<p><code>--target</code> &lt;<em>TARGET</em>&gt;</p>
<p>Use preset configurations for deploying to a specific target.</p>
<p>Possible values are: [beta-1, beta-2, beta-3, latest]</p>
<p><code>--testnet</code> </p>
<p>Use preset configuration for the latest testnet</p>
<p><code>--time-phases</code> </p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>--unsigned</code> </p>
<p>Do not sign the transaction</p>
<p><code>-V</code>, <code>--version</code> </p>
<p>Print version information<!-- markdownlint-disable MD041 --></p>
<h2 id="example-8"><a class="header" href="#example-8">EXAMPLE</a></h2>
<p>You can use <code>forc deploy</code>, which triggers a contract deployment transaction and sends it to a running node.</p>
<p>Alternatively, you can deploy your Sway contract programmatically using <a href="https://github.com/FuelLabs/fuels-rs">fuels-rs</a>, our Rust SDK.</p>
<p>You can find an example within our <a href="https://fuellabs.github.io/fuels-rs/latest/getting-started/basics.html#deploying-a-sway-contract">fuels-rs book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-run"><a class="header" href="#forc-run">forc-run</a></h1>
<p>Run script project. Crafts a script transaction then sends it to a running node</p>
<h2 id="usage-15"><a class="header" href="#usage-15">USAGE:</a></h2>
<p>forc run [OPTIONS] [SIGNING_KEY]</p>
<h2 id="args-6"><a class="header" href="#args-6">ARGS:</a></h2>
<p>&lt;<em>SIGNING_KEY</em>&gt;
Set the key to be used for signing</p>
<h2 id="options-15"><a class="header" href="#options-15">OPTIONS:</a></h2>
<p><code>--ast</code> </p>
<p>Print the generated Sway AST (Abstract Syntax Tree)</p>
<p><code>--build-profile</code> &lt;<em>BUILD_PROFILE</em>&gt;</p>
<p>Name of the build profile to use.</p>
<p>If unspecified, forc will use debug build profile.</p>
<p><code>--contract</code> &lt;<em>CONTRACT</em>&gt;</p>
<p>32-byte contract ID that will be called during the transaction</p>
<p><code>-d</code>, <code>--data</code> &lt;<em>DATA</em>&gt;</p>
<p>Hex string of data to input to script</p>
<p><code>--dca-graph</code> &lt;<em>DCA_GRAPH</em>&gt;</p>
<p>Print the computed Sway DCA graph. DCA graph is printed to the specified path. If
specified '' graph is printed to stdout</p>
<p><code>--dca-graph-url-format</code> &lt;<em>DCA_GRAPH_URL_FORMAT</em>&gt;</p>
<p>Specifies the url format to be used in the generated dot file.
Variables {path}, {line} {col} can be used in the provided format.
An example for vscode would be:
&quot;vscode://file/{path}:{line}:{col}&quot;</p>
<p><code>--dry-run</code> </p>
<p>Only craft transaction and print it out</p>
<p><code>--error-on-warnings</code> </p>
<p>Treat warnings as errors</p>
<p><code>--finalized-asm</code> </p>
<p>Print the finalized ASM.</p>
<p>This is the state of the ASM with registers allocated and optimisations applied.</p>
<p><code>-g</code>, <code>--output-debug</code> &lt;<em>DEBUG_FILE</em>&gt;</p>
<p>If set, outputs source file mapping in JSON format</p>
<p><code>--gas-limit</code> &lt;<em>LIMIT</em>&gt;</p>
<p>Gas limit for the transaction</p>
<p>[default: 100000000]</p>
<p><code>--gas-price</code> &lt;<em>PRICE</em>&gt;</p>
<p>Gas price for the transaction</p>
<p>[default: 0]</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>--intermediate-asm</code> </p>
<p>Print the generated ASM.</p>
<p>This is the state of the ASM prior to performing register allocation and other ASM
optimisations.</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p><code>--ir</code> </p>
<p>Print the generated Sway IR (Intermediate Representation)</p>
<p><code>--json-abi</code> </p>
<p>By default the JSON for ABIs is formatted for human readability. By using this option
JSON output will be &quot;minified&quot;, i.e. all on one line without whitespace</p>
<p><code>--json-abi-with-callpaths</code> </p>
<p>Outputs json abi with callpaths instead of names for struct and enums</p>
<p><code>--json-storage-slots</code> </p>
<p>By default the JSON for initial storage slots is formatted for human readability. By
using this option JSON output will be &quot;minified&quot;, i.e. all on one line without
whitespace</p>
<p><code>--locked</code> </p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs
to be updated, Forc will exit with an error</p>
<p><code>--manual-signing</code> </p>
<p>Sign the deployment transaction manually</p>
<p><code>--maturity</code> &lt;<em>MATURITY</em>&gt;</p>
<p>Block height until which tx cannot be included</p>
<p>[default: 0]</p>
<p><code>--metrics-outfile</code> &lt;<em>METRICS_OUTFILE</em>&gt;</p>
<p>Output compilation metrics into file</p>
<p><code>--node-url</code> &lt;<em>NODE_URL</em>&gt;</p>
<p>The URL of the Fuel node to which we're submitting the transaction. If unspecified,
checks the manifest's <code>network</code> table, then falls back to [<code>crate::default::NODE_URL</code>]</p>
<p>[env: FUEL_NODE_URL=]</p>
<p><code>-o</code>, <code>--output-bin</code> &lt;<em>BIN_FILE</em>&gt;</p>
<p>If set, outputs a binary file representing the script bytes</p>
<p><code>--offline</code> </p>
<p>Offline mode, prevents Forc from using the network when managing dependencies. Meaning
it will only try to use previously downloaded dependencies</p>
<p><code>--output-directory</code> &lt;<em>OUTPUT_DIRECTORY</em>&gt;</p>
<p>The directory in which the sway compiler output artifacts are placed.</p>
<p>By default, this is <code>&lt;project-root&gt;/out</code>.</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>-r</code>, <code>--pretty-print</code> </p>
<p>Pretty-print the outputs from the node</p>
<p><code>--release</code> </p>
<p>Use release build plan. If a custom release plan is not specified, it is implicitly
added to the manifest file.</p>
<p>If --build-profile is also provided, forc omits this flag and uses provided
build-profile.</p>
<p><code>--reverse-order</code> </p>
<p>Output build errors and warnings in reverse order</p>
<p><code>--simulate</code> </p>
<p>Execute the transaction and return the final mutated transaction along with receipts
(which includes whether the transaction reverted or not). The transaction is not
inserted in the node's view of the blockchain, (i.e. it does not affect the chain state)</p>
<p><code>-t</code>, <code>--terse</code> </p>
<p>Terse mode. Limited warning and error output</p>
<p><code>--time-phases</code> </p>
<p>Output the time elapsed over each part of the compilation process</p>
<p><code>--unsigned</code> </p>
<p>Do not sign the transaction</p>
<p><code>-V</code>, <code>--version</code> </p>
<p>Print version information</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-client-1"><a class="header" href="#forc-client-1">forc-client</a></h1>
<p>A <code>forc</code> plugin for interacting with a Fuel node.</p>
<h2 id="usage-16"><a class="header" href="#usage-16">USAGE:</a></h2>
<p>forc-submit [OPTIONS] &lt;TX_PATH&gt;</p>
<h2 id="args-7"><a class="header" href="#args-7">ARGS:</a></h2>
<p>&lt;<em>TX_PATH</em>&gt;
Path to the Transaction that is to be submitted to the Fuel node.</p>
<p>Paths to files ending with <code>.json</code> will be deserialized from JSON. Paths to files ending
with <code>.bin</code> will be deserialized from bytes using the
<code>fuel_tx::Transaction::try_from_bytes</code> constructor.</p>
<h2 id="options-16"><a class="header" href="#options-16">OPTIONS:</a></h2>
<p><code>--await</code> &lt;<em>await</em>&gt;</p>
<p>Whether or not to await confirmation that the transaction has been committed.</p>
<p>When <code>true</code>, await commitment and output the transaction status. When <code>false</code>, do not
await confirmation and simply output the transaction ID.</p>
<p>[default: true]</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>--node-url</code> &lt;<em>NODE_URL</em>&gt;</p>
<p>The URL of the Fuel node to which we're submitting the transaction</p>
<p>[env: FUEL_NODE_URL=]
[default: http://127.0.0.1:4000]</p>
<p><code>--tx-status-json</code> &lt;<em>json</em>&gt;</p>
<p>Output the resulting transaction status as JSON rather than the default output</p>
<p>[default: false]</p>
<p><code>-V</code>, <code>--version</code> </p>
<p>Print version information</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc"><a class="header" href="#forc">Forc</a></h1>
<p>Usage: forc-doc [OPTIONS]</p>
<p>Options:</p>
<p><code>--manifest-path</code> &lt;<em>MANIFEST_PATH</em>&gt;</p>
<p>Path to the Forc.toml file. By default, forc-doc searches for the Forc.toml file in the
current directory or any parent directory</p>
<p><code>--document-private-items</code> </p>
<p>Include non-public items in the documentation</p>
<p><code>--open</code> </p>
<p>Open the docs in a browser after building them</p>
<p><code>--offline</code> </p>
<p>Offline mode, prevents Forc from using the network when managing dependencies. Meaning it
will only try to use previously downloaded dependencies</p>
<p><code>-s</code>, <code>--silent</code> </p>
<p>Silent mode. Don't output any warnings or errors to the command line</p>
<p><code>--locked</code> </p>
<p>Requires that the Forc.lock file is up-to-date. If the lock file is missing, or it needs
to be updated, Forc will exit with an error</p>
<p><code>--no-deps</code> </p>
<p>Do not build documentation for dependencies</p>
<p><code>--ipfs-node</code> &lt;<em>IPFS_NODE</em>&gt;</p>
<p>The IPFS Node to use for fetching IPFS sources.</p>
<p>Possible values: PUBLIC, LOCAL, &lt;GATEWAY_URL&gt;</p>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help (see a summary with '-h')</p>
<p><code>-V</code>, <code>--version</code> </p>
<p>Print version</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-explore"><a class="header" href="#forc-explore">forc-explore</a></h1>
<p>Forc plugin for running the Fuel Block Explorer.</p>
<h2 id="usage-17"><a class="header" href="#usage-17">USAGE:</a></h2>
<p>forc-explore [OPTIONS] [SUBCOMMAND]</p>
<h2 id="options-17"><a class="header" href="#options-17">OPTIONS:</a></h2>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-p</code>, <code>--port</code> &lt;<em>PORT</em>&gt;</p>
<p>The port number at which the explorer will run on localhost [default: 3030]</p>
<p><code>-V</code>, <code>--version</code> </p>
<p>Print version information</p>
<h2 id="subcommands"><a class="header" href="#subcommands">SUBCOMMANDS:</a></h2>
<p><code>clean</code></p>
<p>Cleans up any existing state associated with the fuel block explorer</p>
<p><code>help</code></p>
<p>Print this message or the help of the given subcommand(s)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-fmt"><a class="header" href="#forc-fmt">forc-fmt</a></h1>
<p>Forc plugin for running the Sway code formatter.</p>
<h2 id="usage-18"><a class="header" href="#usage-18">USAGE:</a></h2>
<p>forc-fmt [OPTIONS] [FILE]</p>
<h2 id="args-8"><a class="header" href="#args-8">ARGS:</a></h2>
<p>&lt;<em>FILE</em>&gt;
Formats a single .sw file with the default settings. If not specified, current working
directory will be formatted using a Forc.toml configuration</p>
<h2 id="options-18"><a class="header" href="#options-18">OPTIONS:</a></h2>
<p><code>-c</code>, <code>--check</code> </p>
<p>Run in 'check' mode.</p>
<ul>
<li>Exits with <code>0</code> if input is formatted correctly. - Exits with <code>1</code> and prints a diff if
formatting is required.</li>
</ul>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-p</code>, <code>--path</code> &lt;<em>PATH</em>&gt;</p>
<p>Path to the project, if not specified, current working directory will be used</p>
<p><code>-V</code>, <code>--version</code> </p>
<p>Print version information</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-lsp"><a class="header" href="#forc-lsp">forc-lsp</a></h1>
<p>Forc plugin for the Sway LSP (Language Server Protocol) implementation.</p>
<h2 id="usage-19"><a class="header" href="#usage-19">USAGE:</a></h2>
<p>forc-lsp</p>
<h2 id="options-19"><a class="header" href="#options-19">OPTIONS:</a></h2>
<p><code>-h</code>, <code>--help</code> </p>
<p>Print help information</p>
<p><code>-V</code>, <code>--version</code> </p>
<p>Print version information</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
